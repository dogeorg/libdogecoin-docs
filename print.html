<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Libdogecoin, a clean C library of Dogecoin building blocks</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Libdogecoin will be a complete implementation of the Dogecoin Protocols, as a C library (and series of bindings to popular languages) which will allow anyone to build a Dogecoin compliant product, without needing to worry about the deeper, complicated specifics of the crypto functions.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Libdogecoin, a clean C library of Dogecoin building blocks</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/dogecoinfoundation/libdogecoin/tree/main/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="libdogecoin-a-clean-c-library-of-dogecoin-building-blocks"><a class="header" href="#libdogecoin-a-clean-c-library-of-dogecoin-building-blocks">Libdogecoin, a clean C library of Dogecoin building blocks</a></h1>
<p><img src="images/libdogecoin-logo.png" alt="The LibDogecoin Logo" width="60%" style="margin-left: 20%;"/></p>
<p><a href="https://github.com/dogecoinfoundation/libdogecoin/actions/workflows/ci.yml"><img src="https://github.com/dogecoinfoundation/libdogecoin/actions/workflows/ci.yml/badge.svg" alt="CI" /></a><a href="https://github.com/dogecoinfoundation/libdogecoin/actions/workflows/ql.yml"><img src="https://github.com/dogecoinfoundation/libdogecoin/actions/workflows/ql.yml/badge.svg" alt="CodeQL" /></a></p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="what.html#libdogecoin-a-clean-c-library-of-dogecoin-building-blocks">Libdogecoin, a clean C library of Dogecoin building blocks.</a>
<ul>
<li><a href="what.html#table-of-contents">Table of Contents</a></li>
<li><a href="what.html#what-is-libdogecoin">What is Libdogecoin?</a>
<ul>
<li><a href="what.html#advantages-of-libdogecoin">Advantages of Libdogecoin</a></li>
<li><a href="what.html#current-features">Current features</a></li>
</ul>
</li>
<li><a href="what.html#why-c">Why C?</a></li>
<li><a href="what.html#dogecoin-standardspec">Dogecoin Standard/Spec</a></li>
<li><a href="what.html#code-of-shibes">Code of Shibes</a></li>
<li><a href="what.html#contributing">Contributing</a></li>
<li><a href="what.html#repository-navigation">Repository Navigation</a></li>
<li><a href="what.html#quick-start">Quick Start</a>
<ul>
<li><a href="what.html#preliminary">Preliminary</a></li>
<li><a href="what.html#building">Building</a></li>
<li><a href="what.html#integration">Integration</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="what-is-libdogecoin"><a class="header" href="#what-is-libdogecoin">What is Libdogecoin?</a></h2>
<p>Libdogecoin will be a complete implementation of the Dogecoin Protocols, as a C library (and series of bindings to popular languages) which will allow anyone to build a Dogecoin compliant product, without needing to worry about the deeper, complicated specifics of the crypto functions.</p>
<p>Libdogecoin is here to make crypto development <strong>simple</strong>, <strong>clean</strong>, and <strong>fun</strong>!</p>
<p>This will be a pure library, providing a set of callable functions to implement in external projects, but not a ‘runnable’ node facility. Although we expect building a Dogecoin Node will be a useful test and early outcome, that will live in another repository.</p>
<p>It is intended that connecting the bits together into an engine be done at the level above, via the networking libraries of the host language.</p>
<p><a href="project_roadmap.html">See the Project Roadmap for more on the planned stages of development</a></p>
<p><a href="https://foundation.dogecoin.com/trailmap/libdogecoin/">See the Dogecoin Trailmap for more on libdogecoin</a></p>
<h3 id="advantages-of-libdogecoin"><a class="header" href="#advantages-of-libdogecoin">Advantages of Libdogecoin</a></h3>
<ul>
<li>No dependencies in case no p2p network client is required (only dependencies are <a href="https://github.com/bitcoin-core/secp256k1">libsecp256k1</a> added as git subtree and optionally (enabled by default) <a href="https://www.gnu.org/software/libunistring/">libunistring</a> for mnemonics)</li>
<li>The only dependency for the p2p network client is <a href="https://github.com/libevent/libevent">libevent</a> (very portable)</li>
<li>optimized for MCU and low mem environments</li>
<li>~full test coverage</li>
<li>Best effort to to be mem leak free (manual valgrind check per supported platform)</li>
</ul>
<h3 id="current-features"><a class="header" href="#current-features">Current features</a></h3>
<ul>
<li>Generating and storing private and public keys</li>
<li>ECDSA secp256k1 signing and verification (through <a href="https://github.com/bitcoin-core/secp256k1">libsecp256k1</a> included as git subtree)</li>
<li>Generate recoverable signatures (and recover pubkey from signatures)</li>
<li>BIP32 hierarchical deterministic key derivation</li>
<li>Transaction generation, manipulation, signing and ser-/deserialization including P2PKH, P2SH, multisig</li>
<li>Address generation</li>
<li>Base58check encoding</li>
<li>Native implementation of SHA256, SHA512, SHA512_HMAC, RIPEMD-160 including NIST testvectors</li>
<li>Native constant time AES (+256CBC) cipher implementation including NIST testvectors</li>
<li>Event based dogecoin P2P client capable of connecting to multiple nodes in a single thread (requires <a href="https://github.com/libevent/libevent">libevent</a>)</li>
</ul>
<h2 id="why-c"><a class="header" href="#why-c">Why C?</a></h2>
<p>The Dogecoin Core project is written in C++, why move to C? This is a good question.</p>
<p>The Dogecoin Core project was inherited when Dogecoin was originally forked and makes use of some reasonable heavy C++ libraries that add complexity to the build process, as well as cognitive complexity for new developers.</p>
<p>The desire is to provide a simple to learn library with few external dependencies that can be built with relatively little setup by new developers.  Furthermore the aim of providing wrappers for a number of higher-level languages leans strongly toward either C or RUST from a binding/support perspective, and we believe C still has significantly more support when writing bindings for a wide variety of other languages. C is better supported on embedded/lightweight platforms, with the goal of moving dogecoin beyond the realm of the PC; and actually prepares (constrains it) to be re-coded/adapted in other languages as specific OO and memory mgmt functions of C++ aren't required. Wrappers that previously lived here in this repository have been moved to their own respective projects (python and go bindings) found at <a href="https://github.com/dogeorg">@dogeorg</a>.</p>
<h2 id="dogecoin-standardspec"><a class="header" href="#dogecoin-standardspec">Dogecoin Standard/Spec</a></h2>
<p>During the process of extracting the fundamentals from the Dogecoin Core Wallet (reference implementation) we aim to document ‘how Dogecoin works’ as a suite of tests and documents we are calling the Dogecoin Standard.</p>
<p>See <code>/spec</code></p>
<p>By doing this we will be able to verify that the Libdogecoin implementation of Dogecoin’s internals is accurate to the OG wallet, and thus provide a mechanism for any future Dogecoin implementations to verify compliance with the Dogecoin Network.</p>
<h2 id="code-of-shibes"><a class="header" href="#code-of-shibes">Code of Shibes</a></h2>
<p>By contributing to this repository you agree to be a basic human being, please see <a href="https://github.com/dogecoinfoundation/libdogecoin/blob/main/CONDUCT.md"><code>CONDUCT.md</code></a></p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p><em><strong>TL;DR</strong></em>: Initially during the early phase of development we'll keep this basic, after the library starts to become a dependency for projects in real-world active use this will likely change and the API will become considerably more extensive.</p>
<ul>
<li>Express interest and get added to the libdogecoin team on GitHub
and join the conversation in the Foundation discord server.</li>
<li><strong>Branch/PRs in this repository (see above point for access)</strong></li>
<li><strong>Ensure tests pass and coverage is maintained</strong></li>
<li><strong>Update libdogecoin.h in [<code>/include/</code>] and example.c in [<code>/contrib/examples/</code>]</strong></li>
<li>1 approval from another contributor required to merge to main</li>
<li>Don't introduce dependencies without discussion (MIT); our aim is to have as few dependencies as possible, with the ideal (possibly unachievable) goal of having none beyond standard c libs and a compiler.</li>
<li>Collaborate before you innovate! (this means, discuss what you're working on where everyone can see, before submitting a change.)</li>
<li>Have fun &lt;3</li>
</ul>
<h2 id="repository-navigation"><a class="header" href="#repository-navigation">Repository Navigation</a></h2>
<p>Advice on how to navigate this repository:</p>
<ul>
<li>[<code>/.libs/</code>] where the static library lives after it has been fully built.</li>
<li>[<code>/contrib/&lt;proj&gt;</code>] a place for misc non-core experiments, utils, demo-nodes etc.</li>
<li>[<code>/spec/*.md</code>] a place to begin documenting the Dogecoin Standard as we go.</li>
<li>[<code>/include/dogecoin/*.h</code>] provides header files for libdogecoin users, look here for .h.</li>
<li>[<code>/src/&lt;feature&gt;/*.c,*.h</code>] look here for local .c/.h source implementing the contracts in <code>/include</code>.</li>
<li>[<code>/test/</code>] test suite.</li>
<li>[<code>/</code>] Makefile, license, basic readmes and build control files</li>
</ul>
<p>The documentation has many helpful resources regarding setup and usage of Libdogecoin, along with some educational content on the specifics of Dogecoin protocols. Their contents are listed below:</p>
<ul>
<li><a href="address.html"><code>address.md</code></a> Full description of dogecoin addresses and the Libdogecoin Essential Address API.</li>
<li><a href="getting_started.html"><code>getting_started.md</code></a> Detailed instructions for building, installing, and implementing the library in your project.</li>
<li><a href="project_roadmap.html"><code>project_roadmap.md</code></a> Our plan for the future of Libdogecoin (with pictures!).</li>
<li><a href="tools.html"><code>tools.md</code></a> Guidance on how to use provided helper scripts and tools like <code>such</code> and <code>sendtx</code>.</li>
<li><a href="transaction.html"><code>transaction.md</code></a> Full description of dogecoin transactions and the Libdogecoin Essential Transaction API.</li>
</ul>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>For more detailed build and installation instructions, please refer to <a href="getting_started.html"><code>getting_started.md</code></a></p>
<h3 id="preliminary"><a class="header" href="#preliminary">Preliminary</a></h3>
<p>Before attempting to build, make sure all the necessary dependencies for your architecture are installed.</p>
<p><em>Debian/Ubuntu</em></p>
<pre><code class="language-_Debian/Ubuntu_">sudo apt-get install autoconf automake libtool build-essential libevent-dev libunistring-dev
</code></pre>
<p><em>MacOS</em></p>
<pre><code class="language-_MacOS_">xcode_select --install
sudo chown -R $(whoami) $(brew --prefix)/*
</code></pre>
<p><em>Other</em> - Please submit a pull request to add dependencies for your system, or update these.</p>
<h3 id="building"><a class="header" href="#building">Building</a></h3>
<p><em>Debian / Ubuntu</em></p>
<p>To build the full library, including the <code>such</code> and <code>sendtx</code> CLI tools, run the following autoconf commands:</p>
<pre><code class="language-_Debian / Ubuntu_">./autogen.sh
./configure
make
</code></pre>
<p>To build the pure library without net support, add the following flags to the <code>./configure</code> command:</p>
<pre><code class="language-_Debian / Ubuntu_">./autogen.sh
./configure --disable-net --disable-tools
make
</code></pre>
<h4 id="cmake"><a class="header" href="#cmake">CMake</a></h4>
<p>To build with <code>cmake</code> run the following from the project root directory:</p>
<pre><code class="language-cmake">mkdir build
cd build
cmake ..
cmake --build .
</code></pre>
<h3 id="integration"><a class="header" href="#integration">Integration</a></h3>
<p>Using Libdogecoin in your own project is very simple! Once the library is built, you will see the resulting <code>libdogecoin.a</code> file in the <code>/.libs</code> folder. Additionally, you will want to locate the <code>libdogecoin.h</code> header file in the <code>/include/dogecoin</code> folder. Move both of these files into your project directory, or somewhere where the compiler can find them. In your source code which uses the Libdogecoin API, make sure to include this <code>libdogecoin.h</code> header at the top of your code.</p>
<p>The following instructions show how to build and integrate libdogecoin under Linux, This will vary somewhat for other operating systems; but the process itself should be roughly analogous.</p>
<p>In addition to the following instructions we've created an example file that contains functions stopping at the latest version which is found in <code>/contrib/examples/example.c</code>.</p>
<p>To compile that example with <code>gcc</code>, first build libdogecoin so the resulting <code>.a</code> file will be found in <code>/.libs</code> and execute:</p>
<pre><code class="language-c">gcc ./contrib/examples/example.c ./.libs/libdogecoin.a -I./include/dogecoin -L./.libs -ldogecoin -lunistring -o example
</code></pre>
<p>then run the example: <code>./example</code>. Otherwise continue with something like the folowing:</p>
<p><em>main.c:</em></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include "libdogecoin.h"

int main() {
    // your code here...
}
</code></pre>
<p>Once you are ready to compile, the <code>libdogecoin.a</code> file must be linked to your source code, along with <code>libevent</code> and <code>libunistring</code>. The resulting compilation command will looks similar to this:</p>
<pre><code class="language-_Debian / Ubuntu_">gcc main.c -ldogecoin -levent -lunistring -o myprojectname
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-libdogecoin"><a class="header" href="#getting-started-with-libdogecoin">Getting Started with Libdogecoin</a></h1>
<h2 id="download-pre-built-binaries"><a class="header" href="#download-pre-built-binaries">Download Pre-built Binaries</a></h2>
<p>To use Libdogecoin directly out of the box without making any modifications to the source code, you can download the pre-made binaries from <a href="https://github.com/dogecoinfoundation/libdogecoin/releases">https://github.com/dogecoinfoundation/libdogecoin/releases</a>.
This is the easiest to start with for new developers, but does not enable customization of the library. In order increase control over installation, refer to the section below on manually building Libdogecoin.</p>
<h2 id="building-manually"><a class="header" href="#building-manually">Building Manually</a></h2>
<h3 id="step-1-install-dependencies"><a class="header" href="#step-1-install-dependencies">Step 1: Install Dependencies</a></h3>
<p>For Ubuntu and Debian Linux, you will need to install the following dependencies before building:</p>
<ul>
<li>autoconf</li>
<li>automake</li>
<li>libtool</li>
<li>libevent-dev</li>
<li>libunistring-dev</li>
<li>build-essential</li>
</ul>
<p>This can be done in the following commands using Linux CLI:</p>
<pre><code class="language-c">sudo apt-get update
sudo apt-get install autoconf automake libtool libevent-dev libunistring-dev build-essential
</code></pre>
<p>For Windows, you will need to install the following dependencies before building:</p>
<ul>
<li><a href="https://code.visualstudio.com/download">Visual Studio Code</a></li>
<li><a href="https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2019">Visual Studio Build Tools</a></li>
<li><a href="https://code.visualstudio.com/docs/editor/extension-gallery">C++ and CMake Extensions</a></li>
<li><a href="https://cmake.org/download/">CMake</a></li>
<li><a href="https://git-scm.com/downloads">Git</a></li>
<li><a href="https://www.python.org/downloads/">Python</a></li>
</ul>
<h3 id="step-2-build-libraries"><a class="header" href="#step-2-build-libraries">Step 2: Build Libraries</a></h3>
<p>If all the necessary dependencies have been installed, you can now proceed in building the library. Using autoconf tools, run the <code>./autogen.sh</code> command in terminal:</p>
<pre><code class="language-c">./autogen.sh
</code></pre>
<p>Next, you can configure the library to your liking by specifying flags on the <code>./configure</code> command. (This is especially important for cross compilation as shown in the <a href="getting_started.html#cross-compilation-with-depends">cross compilation section</a>.)</p>
<p>At this step there are plenty of flags that can be specified, the two most pertinent ones being <code>enable-tools/disable-tools</code> and <code>enable-net/disable-net</code>. Both are enabled by default, but if you do not need to use the CLI tools mentioned in <a href="tools.html">tools.md</a> or are not planning to send transactions using Libdogecoin, you may want to consider disabling these flags for simplicity and speed. Here are some examples of possible configurations you can build:</p>
<pre><code class="language-c">./configure
./configure --disable-net --disable-tools
./configure LD_LIBRARY_PATH='path/to/additional/libraries'
./configure CFLAGS='-Ipath/to/additional/include/files'
</code></pre>
<p>If you're building on Windows, you'll need to use <code>cmake</code> instead of <code>./configure</code>:</p>
<pre><code class="language-c">mkdir build
cd build
cmake ..
</code></pre>
<p>Another useful flag is <code>--enable-test-passwd</code>, which will generate a random password for testing software encryption/decryption. This flag disables the need for a password to be entered when testing TPM encryption/decryption. <em>Note: this flag is for testing purposes only.</em> This flag is disabled by default, but can be enabled with the <code>./configure</code> command or by using <code>cmake</code>:</p>
<pre><code class="language-c">./configure --enable-test-passwd
</code></pre>
<pre><code class="language-c">cmake -DTEST_PASSWD=TRUE ..
</code></pre>
<h2 id="--enable-test-passwd-is-for-testing-purposes-only"><a class="header" href="#--enable-test-passwd-is-for-testing-purposes-only"><em><code>--enable-test-passwd</code> is for <strong>testing purposes only</strong>.</em></a></h2>
<p>For a complete list of all different configuration options, you can run the command <code>./configure --help</code>.</p>
<p>Finally, once you have configured the library to your liking, it is ready to be built. This can be done with the simple <code>make</code> command:</p>
<pre><code class="language-c">make
</code></pre>
<p>Or, if you would like to also run our basic unit tests, you can run the command <code>make check</code> which will both build the library and give output showing which files are not passing tests. <em>Note: when compiling with net enabled, this will appear to hang for a couple of seconds after test_tool(), but rest assured that it is running.</em></p>
<pre><code class="language-c">make check
</code></pre>
<p><em>Output:</em></p>
<pre><code class="language-c">make[1]: Entering directory '/home/username/libdogecoin'
make  check-TESTS
make[2]: Entering directory '/home/username/libdogecoin'
PASSED - test_address()
PASSED - test_aes()
PASSED - test_base58()
PASSED - test_bip32()

...

PASSED - test_tool()
PASSED - test_net_basics_plus_download_block()
PASSED - test_protocol()
PASS: tests
=============
1 test passed
=============
make[2]: Leaving directory '/home/username/libdogecoin'
make[1]: Leaving directory '/home/username/libdogecoin'
</code></pre>
<p>On Windows, you will need to run the following commands in the Visual Studio Developer Command Prompt:</p>
<pre><code class="language-c">mkdir build
cd build
cmake ..
cmake --build .
Debug\tests.exe
</code></pre>
<h3 id="step-3-integrate-in-your-project"><a class="header" href="#step-3-integrate-in-your-project">Step 3: Integrate in Your Project</a></h3>
<p>At this point, the library file <code>libdogecoin.a</code> located in the <code>/.libs</code> folder is now fully built and can be moved to any location on your file system. To integrate into your project, you will want to move this file by whatever means (copy-paste, drag-and-drop, <code>mv</code> command, etc.) to a location inside of your project where the linker can find it. If it is not directly in your project folder, you will need to specify the path by using the <code>-L</code> flag during compilation.</p>
<p>You will want to do the same with the <code>libdogecoin.h</code> header (located in <code>/include/dogecoin</code>) in order to integrate the Libdogecoin functions into your source code. Be sure to write an include statement for this file at the top of any source code which uses Libdogecoin, like the example below:</p>
<p><em>main.c:</em></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include "libdogecoin.h"

int main() {
    // your code here...
}
</code></pre>
<p>Again, for compilation later, if <code>libdogecoin.h</code> is not directly next to your source code, specify the path to the header file using the <code>-I</code> flag.</p>
<p>From here, you can call the Libdogecoin API from your program as you normally would any function, as shown below. For more examples on the context in which to use these functions, please refer to <a href="address.html">address.md</a> and <a href="transaction.html">transaction.md</a>. In this particular script, the user is generating a new key pair at which to receive funds, and is constructing a transaction to send funds to this new address from an existing wallet.</p>
<p><em>main.c:</em></p>
<pre><code class="language-c">#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
    dogecoin_ecc_start();

    // establish existing info (utxo is worth 2 doge)
    char *oldPrivKey = "ci5prbqz7jXyFPVWKkHhPq4a9N8Dag3TpeRfuqqC2Nfr7gSqx1fy";
    char *oldPubKey = "031dc1e49cfa6ae15edd6fa871a91b1f768e6f6cab06bf7a87ac0d8beb9229075b";
    char *oldScriptPubKey = "76a914d8c43e6f68ca4ea1e9b93da2d1e3a95118fa4a7c88ac";
    char* utxo_id = "b4455e7b7b7acb51fb6feba7a2702c42a5100f61f61abafa31851ed6ae076074";
    int utxo_vout = 1;
    char* amt_total = "2.0";

    // generate new key pair to send to
    char newPrivKey[PRIVKEYWIFLEN];
    char newPubKey[P2PKHLEN];
    generatePrivPubKeypair(newPrivKey, newPubKey, false);

    // build and sign the transaction
    int idx = start_transaction();
    add_utxo(idx, utxo_id, utxo_vout);
    add_output(idx, newPubKey, "0.69");
    finalize_transaction(idx, newPubKey, "0.00226", amt_total, oldPubKey);
    sign_transaction(idx, oldScriptPubKey, oldPrivKey);

    // print result
    printf("\nFinal signed transaction hex: %s\n\n", get_raw_transaction(idx));

    dogecoin_ecc_stop();
}
</code></pre>
<p>The last step is to specify the libraries you will need to link into your project, done by using the <code>-l</code> flag. The libraries that are required to use Libdogecoin in your project are:</p>
<ul>
<li>libdogecoin (of course!)</li>
<li>libevent_core</li>
<li>libunistring</li>
</ul>
<p>On the command line, your final compilation will look something like the command below, factoring in all of the steps previously mentioned. <em>Note: the prefix "lib" is excluded when specifying libraries to link.</em></p>
<pre><code>gcc main.c -L./path/to/library/file -I./path/to/header/file -ldogecoin -levent_core -lunistring -o myprojectname
</code></pre>
<p>Congratulations, you have just built an executable program that implements Libdogecoin!</p>
<h2 id="cross-compilation-with-depends"><a class="header" href="#cross-compilation-with-depends">Cross Compilation with Depends</a></h2>
<p>There may be times when you would like to build the library for a different operating system than you are currently running. You can do this relatively easily with <code>depends</code>, included in the Libdogecoin repo! The available operating systems you can choose from are the following:</p>
<ul>
<li>arm-linux-gnueabihf</li>
<li>armv7a-linux-android</li>
<li>aarch64-linux-gnu</li>
<li>aarch64-linux-android</li>
<li>x86_64-pc-linux-gnu</li>
<li>x86_64-apple-darwin</li>
<li>x86_64-w64-mingw32</li>
<li>x86_64-linux-android</li>
<li>i686-w64-mingw32</li>
<li>i686-pc-linux-gnu</li>
</ul>
<p>The build steps for cross compilation are very similar to the native build steps listed above. Specify the desired architecture from the list above under by using the <code>HOST</code> flag, and include any necessary configuration flags on the <code>./configure</code> command:</p>
<pre><code class="language-c">make -C depends HOST=&lt;target_architecture&gt;
./autogen.sh
./configure --prefix=`pwd`/depends/&lt;target_architecture&gt;
make check
</code></pre>
<p>It is important to run <code>make check</code> after cross compiling to make sure that everything is running properly for your architecture. For some guidance on which configuration flags to run, you can refer to our <a href="../.github/workflows/ci.yml">CI test file</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libdogecoin-address-api"><a class="header" href="#libdogecoin-address-api">Libdogecoin Address API</a></h1>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of Contents</a></h2>
<ul>
<li><a href="address.html#libdogecoin-address-api">Libdogecoin Address API</a>
<ul>
<li><a href="address.html#table-of-contents">Table of Contents</a></li>
<li><a href="address.html#introduction">Introduction</a>
<ul>
<li><a href="address.html#simple-addresses">Simple Addresses</a></li>
<li><a href="address.html#hd-addresses">HD Addresses</a></li>
<li><a href="address.html#seed-phrases">Seed phrases</a></li>
</ul>
</li>
<li><a href="address.html#simple-address-generation-process">Simple Address Generation Process</a></li>
<li><a href="address.html#essential-address-api">Essential Address API</a>
<ul>
<li><a href="address.html#generateprivpubkeypair"><strong>generatePrivPubKeypair:</strong></a></li>
<li><a href="address.html#generatehdmasterpubkeypair"><strong>generateHDMasterPubKeypair:</strong></a></li>
<li><a href="address.html#generatederivedhdpubkey"><strong>generateDerivedHDPubKey:</strong></a></li>
<li><a href="address.html#verifyprivpubkeypair"><strong>verifyPrivPubKeypair</strong></a></li>
<li><a href="address.html#verifyhdmasterpubkeypair"><strong>verifyHDMasterPubKeypair</strong></a></li>
<li><a href="address.html#verifyp2pkhaddress"><strong>verifyP2pkhAddress</strong></a></li>
<li><a href="address.html#getHDNodePrivateKeyWIFByPath"><strong>getHDNodePrivateKeyWIFByPath</strong></a></li>
<li><a href="address.html#getHDNodeAndExtKeyByPath"><strong>getHDNodeAndExtKeyByPath</strong></a></li>
<li><a href="address.html#getderivedhdaddress"><strong>getDerivedHDAddress</strong></a></li>
<li><a href="address.html#getderivedhdaddressbypath"><strong>getDerivedHDAddressByPath</strong></a></li>
</ul>
</li>
<li><a href="address.html#advanced-address-api">Advanced Address API</a>
<ul>
<li><a href="address.html#generaterandomenglishmnemonic"><strong>generateRandomEnglishMnemonic:</strong></a></li>
<li><a href="address.html#generaterandomenglishmnemonictpm"><strong>generateRandomEnglishMnemonicTPM:</strong></a></li>
<li><a href="address.html#getderivedhdaddressfrommnemonic"><strong>getDerivedHDAddressFromMnemonic:</strong></a></li>
<li><a href="address.html#getderivedhdaddressfromencryptedseed"><strong>getDerivedHDAddressFromEncryptedSeed:</strong></a></li>
<li><a href="address.html#getderivedhdaddressfromencryptedmnemonic"><strong>getDerivedHDAddressFromEncryptedMnemonic:</strong></a></li>
<li><a href="address.html#getderivedhdaddressfromencryptedhdnode"><strong>getDerivedHDAddressFromEncryptedHDNode:</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>A Dogecoin address is the public key of an asymmetric key pair, and provides a designation on the network to hold Dogecoins on the ledger. By holding the private key for an address on the ledger, you have the ability to sign transactions to move (spend/send) the Dogecoins attributed to the address.</p>
<p>Dogecoin addresses can be created in a number of ways, each with benefits depending on the objective of the address owner(s). A couple of these are listed below:</p>
<h3 id="simple-addresses"><a class="header" href="#simple-addresses">Simple Addresses</a></h3>
<p>These are the most common form of Dogecoin address, a single private key with a single public key (address). Most often these are what an exchange would use to retain full custody of a wallet on behalf of their users, or for a simple desktop / mobile wallet they provide a basic approach to address management.</p>
<h3 id="hd-addresses"><a class="header" href="#hd-addresses">HD Addresses</a></h3>
<p>HD, or <em>Hierarchical Deterministic</em> addresses, unlike simple addresses are created from a seed key-phrase, usually twelve random unique words rather than a 256-bit private key. The key-phrase is then used (with the addition of a simple, incrementing number) to generate an unlimited supply of public Dogecoin addresses which the holder of the key-phrase can sign.</p>
<h3 id="seed-phrases"><a class="header" href="#seed-phrases">Seed phrases</a></h3>
<p>Seed phrases, also known as mnemonic phrases, are a commonly used method to create and backup HD addresses. These phrases consist of 12 or 24 random words, generated from a 128 or 256-bit entropy source, respectively. Seed phrases can then be used to generate an HD address.</p>
<p>When using seed phrases to generate HD addresses, it is essential to ensure the security of the seed phrase. Seed phrases should be treated with extreme caution and must be stored safely in a secure location. There are several steps that you can take to ensure that your seed phrase remains secure:</p>
<ul>
<li>Do not type your seed phrase into any device connected to the internet, as it could be compromised by malware or keyloggers.</li>
<li>Store your seed phrase offline in a secure and tamper-evident location, such as a hardware wallet, paper wallet or encrypted digital storage device.</li>
<li>Do not share your seed phrase with anyone, as it grants access to all the funds in your wallet.</li>
<li>Use a strong, unique and memorable passphrase to protect your seed phrase from unauthorized access.</li>
</ul>
<p>When embedding libdogecoin in your project, it is important to consider the wallet type you are using. HD wallets, which use seed phrases to generate addresses, are generally considered more secure than simple wallets, which use a single private key for all addresses. Hot wallets, which are connected to the internet, are more convenient to use but are also more vulnerable to attacks. Cold wallets, which are kept offline, are more secure but may be less convenient to use for frequent transactions. You should carefully consider your security needs and choose the appropriate wallet type for your project.</p>
<h2 id="simple-address-generation-process"><a class="header" href="#simple-address-generation-process">Simple Address Generation Process</a></h2>
<p>The first step to create a simple pay-to-public-key-hash (p2pkh) address is to generate the private key, which is a randomly generated 256-bit (32-byte) unsigned integer. This must be done within a secp256k1 context in order to generate a private key, as this context ensures the key's validity can be mathematically proven by other validators.</p>
<p>This random private key is then encoded into wallet import format (WIF) which makes the private key readable and easier to copy. If viewing this private key, <strong>DO NOT REVEAL IT TO ANYONE ELSE</strong>! This private key grants you the ability to spend any Dogecoin sent to any public key associated with this private key, and sharing it will compromise all funds in your wallet.</p>
<p>The next step in the process is deriving the public key from the private key, using the mathematical properties of the secp256k1 elliptical curve (this is done internally by Libdogecoin). This should be done within the same context that was created at the beginning of the session, because it is expensive to regenerate all the cryptographic information necessary and this extraneous computation should be avoided.</p>
<p>One thing to note is that this public key is <strong>NOT</strong> the same as a Dogecoin address. The final step in the address generation process is to convert the public key (in the form of seemingly random bytes) into a readable, valid Dogecoin address. The steps for achieving this are as follows:</p>
<ul>
<li>Pass the public key once through a SHA256 hash function.</li>
<li>Pass the result of this hash into a RIPEMD-160 hash function.</li>
<li>Prefix this RIPEMD-160 result with the character associated with the specified blockchain. <em>('D' for mainnet, 'n' for testnet)</em></li>
<li>Double-hash the current string (prefix + RIPEMD-160 result) with SHA256 and save the result as a 32-byte checksum.</li>
<li>Append the first 4 bytes of this checksum to the current string.</li>
<li>Encode the current string with base58 to get the final Dogecoin p2pkh address.</li>
</ul>
<p>You now have a valid Dogecoin address! Its validity can be checked using the verifyPrivPubKeypair() function, which assesses whether the checksum holds after the address undergoes base58 decoding. Keep in mind, the public key cannot be derived from this p2pkh address because it was passed through irreversible hash functions. However, this address can now be used to receive funds and eventually spend them using the private key generated in the beginning.</p>
<p>These steps can be very confusing, so Libdogecoin does all of them for you when you call <code>generatePrivPubKeyPair()</code>, from private key generation to public key derivation to p2pkh address conversion. The process is very similar for HD key pair generation but with a little more complexity involved in generating the raw key pair. For more information on how to call the functions that perform the process listed above, see the Essential API description below.</p>
<h2 id="essential-address-api"><a class="header" href="#essential-address-api">Essential Address API</a></h2>
<p>These functions implement the core functionality of Libdogecoin for address generation and validation, and are described in depth below. You can access them through a C program, by including the <code>libdogecoin.h</code> header in the source code and including the <code>libdogecoin.a</code> library at compile time.</p>
<p>When using functions from either the Essential or Advanced Address API, include the -lunistring flag during the linking process. This is because the Advanced Address API uses the GNU libunistring library for Unicode string manipulation. To include the -lunistring flag during linking, simply add it to the linker command when building your project:</p>
<p><code>gcc -o example example.c -ldogecoin -lunistring</code></p>
<p>Ensure that the <code>libunistring</code> library is installed on your system before linking.</p>
<hr />
<h3 id="generateprivpubkeypair"><a class="header" href="#generateprivpubkeypair"><strong>generatePrivPubKeypair:</strong></a></h3>
<p><code>int generatePrivPubKeypair(char* wif_privkey, char* p2pkh_pubkey, bool is_testnet)</code></p>
<p>This function will populate provided string variables (privkey, pubkey) with freshly generated respective private and public keys, specifically for either mainnet or testnet as specified through the network flag (is_testnet). The function returns 1 on success and 0 on failure.</p>
<p><em>C usage:</em></p>
<pre><code class="language-c">#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
  int privkeyLen = PRIVKEYWIFLEN;
  int pubkeyLen = P2PKHLEN;

  char privKey[privkeyLen];
  char pubKey[pubkeyLen];

  dogecoin_ecc_start();
  generatePrivPubKeypair(privKey, pubKey, false); // generating a mainnet pair
  dogecoin_ecc_stop();

  printf("My private key for mainnet is: %s\n", privKey);
  printf("My public key for mainnet is: %s\n", pubKey);
}
</code></pre>
<hr />
<h3 id="generatehdmasterpubkeypair"><a class="header" href="#generatehdmasterpubkeypair"><strong>generateHDMasterPubKeypair:</strong></a></h3>
<p><code>int generateHDMasterPubKeypair(char* hd_privkey_master, char* p2pkh_pubkey_master, bool is_testnet)</code></p>
<p>This function will populate provided string variables (privkey, pubkey) with freshly generated respective private and public keys for a hierarchical deterministic wallet, specifically for either mainnet or testnet as specified through the network flag (is_testnet). The function returns 1 on success and 0 on failure.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
  int masterPrivkeyLen = HDKEYLEN; // enough cushion
  int pubkeyLen = P2PKHLEN;

  char masterPrivKey[masterPrivkeyLen];
  char masterPubKey[pubkeyLen];

  dogecoin_ecc_start();
  generateHDMasterPubKeypair(masterPrivKey, masterPubKey, false);
  dogecoin_ecc_stop();

  printf("My private key for mainnet is: %s\n", masterPrivKey);
  printf("My public key for mainnet is: %s\n", masterPubKey);
}
</code></pre>
<hr />
<h3 id="generatederivedhdpubkey"><a class="header" href="#generatederivedhdpubkey"><strong>generateDerivedHDPubKey:</strong></a></h3>
<p><code>int generateDerivedHDPubkey(const char* hd_privkey_master, char* p2pkh_pubkey)</code></p>
<p>This function takes a given HD master private key (hd_privkey_master) and loads it into the provided pointer for the resulting derived public key (p2pkh_pubkey). This private key input should come from the result of generateHDMasterPubKeypair(). The function returns 1 on success and 0 on failure.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
  int masterPrivkeyLen = HDKEYLEN; // enough cushion
  int pubkeyLen = P2PKHLEN;

  char masterPrivKey[masterPrivkeyLen];
  char masterPubKey[pubkeyLen];
  char childPubKey[pubkeyLen];

  dogecoin_ecc_start();
  generateHDMasterPubKeypair(masterPrivKey, masterPubKey, false);
  generateDerivedHDPubkey(masterPrivKey, childPubKey);
  dogecoin_ecc_stop();

  printf("master private key: %s\n", masterPrivKey);
  printf("master public key: %s\n", masterPubKey);
  printf("derived child key: %s\n", childPubKey);
}
</code></pre>
<hr />
<h3 id="verifyprivpubkeypair"><a class="header" href="#verifyprivpubkeypair"><strong>verifyPrivPubKeypair</strong></a></h3>
<p><code>int verifyPrivPubKeypair(char* wif_privkey, char* p2pkh_pubkey, bool is_testnet)</code></p>
<p>This function requires a previously generated key pair (wif_privkey, p2pkh_pubkey) and the network they were generated for (is_testnet). It then validates that the given public key was indeed derived from the given private key, returning 1 if the keys are associated and 0 if they are not. This could be useful prior to signing, or in some kind of wallet recovery tool to match keys.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
  int privkeyLen = PRIVKEYWIFLEN;
  int pubkeyLen = P2PKHLEN;

  char privKey[privkeyLen];
  char pubKey[pubkeyLen];

  dogecoin_ecc_start();
  generatePrivPubKeypair(privKey, pubKey, false);

  if (verifyPrivPubKeypair(privKey, pubKey, false)) {
    printf("Keypair is valid.\n");
  }
  else {
    printf("Keypair is invalid.\n");
  }
  dogecoin_ecc_stop();
}
</code></pre>
<hr />
<h3 id="verifyhdmasterpubkeypair"><a class="header" href="#verifyhdmasterpubkeypair"><strong>verifyHDMasterPubKeypair</strong></a></h3>
<p><code>int verifyHDMasterPubKeypair(char* hd_privkey_master, char* p2pkh_pubkey_master, bool is_testnet)</code></p>
<p>This function validates that a given master private key matches a given master public key. This could be useful prior to signing, or in some kind of wallet recovery tool to match keys. This function requires a previously generated HD master key pair (hd_privkey_master, p2pkh_pubkey_master) and the network they were generated for (is_testnet). It then validates that the given public key was indeed derived from the given master private key, returning 1 if the keys are associated and 0 if they are not. This could be useful prior to signing, or in some kind of wallet recovery tool to match keys.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
  int masterPrivkeyLen = HDKEYLEN; // enough cushion
  int pubkeyLen = P2PKHLEN;

  char masterPrivKey[masterPrivkeyLen];
  char masterPubKey[pubkeyLen];

  dogecoin_ecc_start();
  generateHDMasterPubKeypair(masterPrivKey, masterPubKey, false);

  if (verifyHDMasterPubKeypair(masterPrivKey, masterPubKey, false)) {
    printf("Keypair is valid.\n");
  }
  else {
    printf("Keypair is invalid.\n");
  }
  dogecoin_ecc_stop();
}
</code></pre>
<hr />
<h3 id="verifyp2pkhaddress"><a class="header" href="#verifyp2pkhaddress"><strong>verifyP2pkhAddress</strong></a></h3>
<p><code>int verifyP2pkhAddress(char* p2pkh_pubkey, uint8_t len)</code></p>
<p>This function accepts an existing public key (p2pkh_pubkey) and its length in characters (len) to perform some basic validation to determine if it looks like a valid Dogecoin address. It returns 1 if the address is valid and 0 if it is not. This is useful for wallets that want to check that a recipient address looks legitimate.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
  int privkeyLen = HDKEYLEN; // enough cushion
  int pubkeyLen = P2PKHLEN;

  char privKey[privkeyLen];
  char pubKey[pubkeyLen];

  dogecoin_ecc_start();
  generatePrivPubKeypair(privKey, pubKey, false);

  if (verifyP2pkhAddress(pubKey, strlen(pubKey))) {
    printf("Address is valid.\n");
  }
  else {
    printf("Address is invalid.\n");
  }
  dogecoin_ecc_stop();
}
</code></pre>
<hr />
<h3 id="gethdnodeprivatekeywifbypath"><a class="header" href="#gethdnodeprivatekeywifbypath"><strong>getHDNodePrivateKeyWIFByPath</strong></a></h3>
<p><code>char* getHDNodePrivateKeyWIFByPath(const char* masterkey, const char* derived_path, char* outaddress, bool outprivkey)</code></p>
<p>This function derives a hierarchical deterministic child key by way of providing the extended master key, derived_path, outaddress and outprivkey.
It will return the dogecoin_hdnode's private key serialized in WIF format if successful and exits if the proper arguments are not provided.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;

int main() {
  size_t extoutsize = 112;
  char* extout = dogecoin_char_vla(extoutsize);
  char* masterkey_main_ext = "dgpv51eADS3spNJh8h13wso3DdDAw3EJRqWvftZyjTNCFEG7gqV6zsZmucmJR6xZfvgfmzUthVC6LNicBeNNDQdLiqjQJjPeZnxG8uW3Q3gCA3e";
  dogecoin_ecc_start();
  u_assert_str_eq(getHDNodePrivateKeyWIFByPath(masterkey_main_ext, "m/44'/3'/0'/0/0", extout, true), "QNvtKnf9Qi7jCRiPNsHhvibNo6P5rSHR1zsg3MvaZVomB2J3VnAG");
  u_assert_str_eq(extout, "dgpv5BeiZXttUioRMzXUhD3s2uE9F23EhAwFu9meZeY9G99YS6hJCsQ9u6PRsAG3qfVwB1T7aQTVGLsmpxMiczV1dRDgzpbUxR7utpTRmN41iV7");
  dogecoin_ecc_stop();
  free(extout);
}
</code></pre>
<hr />
<h3 id="gethdnodeandextkeybypath"><a class="header" href="#gethdnodeandextkeybypath"><strong>getHDNodeAndExtKeyByPath</strong></a></h3>
<p><code>dogecoin_hdnode* getHDNodeAndExtKeyByPath(const char* masterkey, const char* derived_path, char* outaddress, bool outprivkey)</code></p>
<p>This function derives a hierarchical deterministic child key by way of providing the extended master key, derived_path, outaddress and outprivkey.  The masterkey can be either a private or public key, but if it is a public key, the outprivkey flag must be set to false and the derived_path must be a public derivation path.
It will return the dogecoin_hdnode if successful and exits if the proper arguments are not provided.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;

int main() {
  size_t extoutsize = 112;
  char* extout = dogecoin_char_vla(extoutsize);
  char* masterkey_main_ext = "dgpv51eADS3spNJh8h13wso3DdDAw3EJRqWvftZyjTNCFEG7gqV6zsZmucmJR6xZfvgfmzUthVC6LNicBeNNDQdLiqjQJjPeZnxG8uW3Q3gCA3e";
  dogecoin_ecc_start();
  dogecoin_hdnode* hdnode = getHDNodeAndExtKeyByPath(masterkey_main_ext, "m/44'/3'/0'/0/0", extout, true);
  u_assert_str_eq(utils_uint8_to_hex(hdnode-&gt;private_key, sizeof hdnode-&gt;private_key), "09648faa2fa89d84c7eb3c622e06ed2c1c67df223bc85ee206b30178deea7927");
  dogecoin_privkey_encode_wif((const dogecoin_key*)hdnode-&gt;private_key, &amp;dogecoin_chainparams_main, privkeywif_main, &amp;wiflen);
  u_assert_str_eq(privkeywif_main, "QNvtKnf9Qi7jCRiPNsHhvibNo6P5rSHR1zsg3MvaZVomB2J3VnAG");
  u_assert_str_eq(extout, "dgpv5BeiZXttUioRMzXUhD3s2uE9F23EhAwFu9meZeY9G99YS6hJCsQ9u6PRsAG3qfVwB1T7aQTVGLsmpxMiczV1dRDgzpbUxR7utpTRmN41iV7");
  dogecoin_ecc_stop();
  dogecoin_hdnode_free(hdnode);
  free(extout);
}
</code></pre>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;

int main() {
  char masterkey[HDKEYLEN] = {0};
  char master_public_key[HDKEYLEN] = {0};
  char extkeypath[KEYPATHMAXLEN] = "m/0/0/0/0/0";
  char extpubkey[HDKEYLEN] = {0};
  dogecoin_ecc_start();

  // Generate a master key pair from the seed, and then get the master public key
  getHDRootKeyFromSeed(utils_hex_to_uint8("5eb00bbddcf069084889a8ab9155568165f5c453ccb85e70811aaed6f6da5fc19a5ac40b389cd370d086206dec8aa6c43daea6690f20ad3d8d48b2d2ce9e38e4"), MAX_SEED_SIZE, false, masterkey);
  getHDPubKey(masterkey, false, master_public_key);

  // Derive an extended normal (non-hardened) public key from the master public key
  getHDNodeAndExtKeyByPath(master_public_key, extkeypath, extpubkey, false);
  dogecoin_ecc_stop();
  printf("%s\n", extpubkey);
}
</code></pre>
<hr />
<h3 id="getderivedhdaddress"><a class="header" href="#getderivedhdaddress"><strong>getDerivedHDAddress</strong></a></h3>
<p><code>int getDerivedHDAddress(const char* masterkey, uint32_t account, bool ischange, uint32_t addressindex, char* outaddress, bool outprivkey)</code></p>
<p>This function derives a hierarchical deterministic address by way of providing the extended master key, account, ischange and addressindex.
It will return 1 if the function is successful and 0 if not.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;

int main() {
  size_t extoutsize = 112;
  char* extout = dogecoin_char_vla(extoutsize);
  char* masterkey_main_ext = "dgpv51eADS3spNJh8h13wso3DdDAw3EJRqWvftZyjTNCFEG7gqV6zsZmucmJR6xZfvgfmzUthVC6LNicBeNNDQdLiqjQJjPeZnxG8uW3Q3gCA3e";
  dogecoin_ecc_start();
  int res = getDerivedHDAddress(masterkey_main_ext, 0, false, 0, extout, true);
  u_assert_int_eq(res, true);
  u_assert_str_eq(extout, "dgpv5BeiZXttUioRMzXUhD3s2uE9F23EhAwFu9meZeY9G99YS6hJCsQ9u6PRsAG3qfVwB1T7aQTVGLsmpxMiczV1dRDgzpbUxR7utpTRmN41iV7");
  dogecoin_ecc_stop();
  free(extout);
}
</code></pre>
<hr />
<h3 id="getderivedhdaddressbypath"><a class="header" href="#getderivedhdaddressbypath"><strong>getDerivedHDAddressByPath</strong></a></h3>
<p><code>int getDerivedHDAddressByPath(const char* masterkey, const char* derived_path, char* outaddress, bool outprivkey)</code></p>
<p>This function derives an extended HD address by custom path in string format (derived_path).
It returns 1 if the address is valid and 0 if it is not.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;

int main() {
  size_t extoutsize = 112;
  char* extout = dogecoin_char_vla(extoutsize);
  char* masterkey_main_ext = "dgpv51eADS3spNJh8h13wso3DdDAw3EJRqWvftZyjTNCFEG7gqV6zsZmucmJR6xZfvgfmzUthVC6LNicBeNNDQdLiqjQJjPeZnxG8uW3Q3gCA3e";
  dogecoin_ecc_start();
  res = getDerivedHDAddressByPath(masterkey_main_ext, "m/44'/3'/0'/0/0", extout, true);
  u_assert_int_eq(res, true);
  u_assert_str_eq(extout, "dgpv5BeiZXttUioRMzXUhD3s2uE9F23EhAwFu9meZeY9G99YS6hJCsQ9u6PRsAG3qfVwB1T7aQTVGLsmpxMiczV1dRDgzpbUxR7utpTRmN41iV7");
  dogecoin_ecc_stop();
  free(extout);
}
</code></pre>
<h2 id="advanced-address-api"><a class="header" href="#advanced-address-api">Advanced Address API</a></h2>
<p>These functions implement advanced functionality of Libdogecoin for address generation and validation, and are described in depth below. You can access them through a C program, by including the <code>libdogecoin.h</code> header in the source code and including the <code>libdogecoin.a</code> library at compile time.</p>
<hr />
<h3 id="generaterandomenglishmnemonic"><a class="header" href="#generaterandomenglishmnemonic"><strong>generateRandomEnglishMnemonic</strong></a></h3>
<p><code>int generateRandomEnglishMnemonic(const ENTROPY_SIZE size, MNEMONIC mnemonic);</code></p>
<p>This function generates a random English mnemonic phrase (seed phrase). The function returns 0 on success and -1 on failure.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main () {
  MNEMONIC seed_phrase;

  dogecoin_ecc_start();
  generateRandomEnglishMnemonic("256", seed_phrase);
  dogecoin_ecc_stop();

  printf("%s\n", seed_phrase);
}
</code></pre>
<p><em>C++ usage:</em></p>
<pre><code class="language-C++">extern "C" {
#include "libdogecoin.h"
}
#include &lt;iostream&gt;
using namespace std;

int main () {
  MNEMONIC seed_phrase;

  dogecoin_ecc_start();
  generateRandomEnglishMnemonic("256", seed_phrase);
  dogecoin_ecc_stop();

  cout &lt;&lt; seed_phrase &lt;&lt; endl;
}
</code></pre>
<hr />
<h3 id="generaterandomenglishmnemonictpm"><a class="header" href="#generaterandomenglishmnemonictpm"><strong>generateRandomEnglishMnemonicTPM</strong></a></h3>
<p><code>dogecoin_bool generateRandomEnglishMnemonicTPM(MNEMONIC mnemonic, const int file_num, const dogecoin_bool overwrite);</code></p>
<p>This function generates a random English mnemonic using a TPM (Trusted Platform Module). It stores the generated mnemonic in the provided <code>mnemonic</code> buffer. The <code>file_num</code> parameter specifies the encrypted storage file number, and the <code>overwrite</code> parameter indicates whether to overwrite an existing mnemonic in the encrypted storage. The function returns <code>TRUE</code> on success and <code>FALSE</code> on failure.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">
#include "libdogecoin.h"

int main() {
    MNEMONIC mnemonic;
    int file_num = 0;  // Specify the TPM storage file number
    dogecoin_bool overwrite = TRUE;  // Set to TRUE to overwrite existing mnemonic

    if (generateRandomEnglishMnemonicTPM(mnemonic, file_num, overwrite)) {
        printf("Generated mnemonic: %s\n", mnemonic);
    } else {
        printf("Error generating mnemonic.\n");
        return -1;
    }
}
</code></pre>
<hr />
<h3 id="getderivedhdaddressfrommnemonic"><a class="header" href="#getderivedhdaddressfrommnemonic"><strong>getDerivedHDAddressFromMnemonic</strong></a></h3>
<p><code>int getDerivedHDAddressFromMnemonic(const uint32_t account, const uint32_t index, const CHANGE_LEVEL change_level, const MNEMONIC mnemonic, const PASS pass, char* p2pkh_pubkey, const bool is_testnet);</code></p>
<p>This function generates a new dogecoin address from a mnemonic and a slip44 key path.  The function returns 0 on success and -1 on failure.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main () {
  int addressLen = P2PKHLEN;

  MNEMONIC seed_phrase;
  char address [addressLen];

  dogecoin_ecc_start();
  generateRandomEnglishMnemonic("256", seed_phrase);
  getDerivedHDAddressFromMnemonic(0, 0, "0", seed_phrase, NULL, address, false);
  dogecoin_ecc_stop();

  printf("%s\n", seed_phrase);
  printf("%s\n", address);
}
</code></pre>
<p><em>C++ usage:</em></p>
<pre><code class="language-C++">extern "C" {
#include "libdogecoin.h"
}
#include &lt;iostream&gt;
using namespace std;

int main () {
  int addressLen = P2PKHLEN;

  MNEMONIC seed_phrase;
  char address [addressLen];

  dogecoin_ecc_start();
  generateRandomEnglishMnemonic("256", seed_phrase);
  getDerivedHDAddressFromMnemonic(0, 0, "0", seed_phrase, NULL, address, false);
  dogecoin_ecc_stop();

  cout &lt;&lt; seed_phrase &lt;&lt; endl;
  cout &lt;&lt; address &lt;&lt; endl;
}
</code></pre>
<hr />
<h3 id="getderivedhdaddressfromencryptedseed"><a class="header" href="#getderivedhdaddressfromencryptedseed"><strong>getDerivedHDAddressFromEncryptedSeed</strong></a></h3>
<p><code>int getDerivedHDAddressFromEncryptedSeed(const uint32_t account, const uint32_t index, const CHANGE_LEVEL change_level, char* p2pkh_pubkey, const dogecoin_bool is_testnet, const int file_num);</code></p>
<p>This function generates a new Dogecoin address from an encrypted seed and a slip44 key path. The function returns 0 on success and -1 on failure.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">
#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
    int addressLen = P2PKHLEN;
    char derived_address[addressLen];

    if (getDerivedHDAddressFromEncryptedSeed(0, 0, BIP44_CHANGE_EXTERNAL, derived_address, false, TEST_FILE) == 0) {
        printf("Derived address: %s\n", derived_address);
    } else {
        printf("Error occurred.\n");
        return -1;
    }
}
</code></pre>
<hr />
<h3 id="getderivedhdaddressfromencryptedmnemonic"><a class="header" href="#getderivedhdaddressfromencryptedmnemonic"><strong>getDerivedHDAddressFromEncryptedMnemonic</strong></a></h3>
<p><code>int getDerivedHDAddressFromEncryptedMnemonic(const uint32_t account, const uint32_t index, const CHANGE_LEVEL change_level, const PASS pass, char* p2pkh_pubkey, const bool is_testnet, const int file_num);</code></p>
<p>This function generates a new Dogecoin address from an encrypted mnemonic and a slip44 key path. The function returns 0 on success and -1 on failure.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">
#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
    int addressLen = P2PKHLEN;
    char derived_address[addressLen];

    if (getDerivedHDAddressFromEncryptedMnemonic(0, 0, BIP44_CHANGE_EXTERNAL, NULL, derived_address, false, TEST_FILE) == 0) {
        printf("Derived address: %s\n", derived_address);
    } else {
        printf("Error occurred.\n");
        return -1;
    }
}
</code></pre>
<hr />
<h3 id="getderivedhdaddressfromencryptedhdnode"><a class="header" href="#getderivedhdaddressfromencryptedhdnode"><strong>getDerivedHDAddressFromEncryptedHDNode</strong></a></h3>
<p><code>int getDerivedHDAddressFromEncryptedHDNode(const uint32_t account, const uint32_t index, const CHANGE_LEVEL change_level, char* p2pkh_pubkey, const bool is_testnet, const int file_num);</code></p>
<p>This function generates a new Dogecoin address from an encrypted HD node and a slip44 key path. The function returns 0 on success and -1 on failure.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">
#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
    int addressLen = P2PKHLEN;
    char derived_address[addressLen];

    if (getDerivedHDAddressFromEncryptedHDNode(0, 0, BIP44_CHANGE_EXTERNAL, derived_address, false, TEST_FILE) == 0) {
        printf("Derived address: %s\n", derived_address);
    } else {
        printf("Error occurred.\n");
        return -1;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libdogecoin-elliptic-curve-key-api"><a class="header" href="#libdogecoin-elliptic-curve-key-api">Libdogecoin Elliptic Curve Key API</a></h1>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of Contents</a></h2>
<ul>
<li><a href="eckey.html#libdogecoin-elliptic-curve-key-api">Libdogecoin Elliptic Curve Key API</a>
<ul>
<li><a href="eckey.html#table-of-contents">Table of Contents</a></li>
<li><a href="eckey.html#abstract">Abstract</a></li>
<li><a href="eckey.html#specification">Specification</a></li>
<li><a href="eckey.html#primitives">Primitives</a></li>
<li><a href="eckey.html#basic-elliptic-curve-key-api">Basic Elliptic Curve Key API</a>
<ul>
<li><a href="eckey.html#eckey"><strong>eckey:</strong></a></li>
<li><a href="eckey.html#keys"><strong>keys:</strong></a></li>
<li><a href="eckey.html#new_eckey"><strong>new_eckey:</strong></a></li>
<li><a href="eckey.html#new_eckey_from_privkey"><strong>new_eckey_from_privkey:</strong></a></li>
<li><a href="eckey.html#add_eckey"><strong>add_eckey:</strong></a></li>
<li><a href="eckey.html#start_key"><strong>start_key:</strong></a></li>
<li><a href="eckey.html#find_eckey"><strong>find_eckey:</strong></a></li>
<li><a href="eckey.html#remove_eckey"><strong>remove_eckey:</strong></a></li>
<li><a href="eckey.html#dogecoin_key_free"><strong>dogecoin_key_free:</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<p>This document explains the basic elliptic curve key API within libdogecoin.</p>
<h2 id="specification"><a class="header" href="#specification">Specification</a></h2>
<p>Cited from <a href="https://en.bitcoin.it/wiki/Elliptic_Curve_Digital_Signature_Algorithm">https://en.bitcoin.it/wiki/Elliptic_Curve_Digital_Signature_Algorithm</a></p>
<h3 id="background-on-ecdsa-signatures"><a class="header" href="#background-on-ecdsa-signatures">Background on ECDSA Signatures</a></h3>
<p>Elliptic Curve Digital Signature Algorithm or ECDSA is a cryptographic algorithm used by Dogecoin to ensure that funds can only be spent by their rightful owners. It is dependent on the curve order and hash function used. For dogecoin these are Secp256k1 and SHA256(SHA256()) respectively.</p>
<p>A few concepts related to ECDSA:</p>
<ul>
<li><code>private key</code>: A secret number, known only to the person that generated it. A private key is essentially a randomly generated number. In Dogecoin, someone with the private key that corresponds to funds on the blockchain can spend the funds. In Dogecoin, a private key is a single unsigned 256 bit integer (32 bytes).</li>
<li><code>public key</code>: A number that corresponds to a private key, but does not need to be kept secret. A public key can be calculated from a private key, but not vice versa. A public key can be used to determine if a signature is genuine (in other words, produced with the proper key) without requiring the private key to be divulged. In Dogecoin, public keys are either compressed or uncompressed. Compressed public keys are 33 bytes, consisting of a prefix either 0x02 or 0x03, and a 256-bit integer called x. The older uncompressed keys are 65 bytes, consisting of constant prefix (0x04), followed by two 256-bit integers called x and y (2 * 32 bytes). The prefix of a compressed key allows for the y value to be derived from the x value.</li>
<li><code>signature</code>: A number that proves that a signing operation took place. A signature is mathematically generated from a hash of something to be signed, plus a private key. The signature itself is two numbers known as r and s. With the public key, a mathematical algorithm can be used on the signature to determine that it was originally produced from the hash and the private key, without needing to know the private key. Resulting signatures are either 73, 72, or 71 bytes long (with approximate probabilities of 25%, 50%, and 25%, respectively--although sizes even smaller than that are possible with exponentially decreasing probability).</li>
</ul>
<h3 id="primitives"><a class="header" href="#primitives">Primitives</a></h3>
<p>The ECDSA signing and verification algorithms make use of a few fundamental variables which are used to obtain a signature and the reverse process of getting a message from a signature.</p>
<ul>
<li><code>r</code> and <code>s</code>: These numbers uniquely represent the signature.</li>
<li><code>z</code>: The hash of the message we want to sign. Normally we are required to use the left-most N bits of the message hash, where <code>N</code> is the length of the hash function used, however, this rule does not apply to dogecoin signatures because the length of the hash function used, SHA256, equals the bit length of the secp256k1 curve (256) so no truncation is necessary.</li>
<li><code>k</code>: A cryptographicly secure random number which is used as a nonce to calculate the <code>r</code> and <code>s</code> values.</li>
<li><code>dA</code> and <code>QA</code>: These are the private key number and public key point respectively, used to sign and verify the message. Wallets can derive a copy of these when give an address contained inside the wallet.</li>
</ul>
<h3 id="verification-algorithm"><a class="header" href="#verification-algorithm">Verification Algorithm</a></h3>
<p>The verification algorithm ensures that the signature pair <code>r</code> and <code>s</code>, <code>QA</code> and <code>z</code> are all consistent.</p>
<ul>
<li>Verify that both <code>r</code> and <code>s</code> are between <code>1</code> and <code>n-1</code>.</li>
<li>Compute <code>u1 = z*s-1 mod n</code> and <code>u2 = r*s-1 mod n</code>.</li>
<li>Compute <code>(x, y) = u1*G + u2*QA</code> and ensure it is not equal to the point at infinity. The point at infinity is a special point that results when you add two points whose result would otherwise not lie on the curve, such as two points with the same <code>X</code> value but inverted <code>Y</code> values.</li>
<li>If <code>r = x mod n</code> then the signature is valid. Otherwise, or if any of the checks fail, then the signature is invalid.</li>
</ul>
<h2 id="basic-elliptic-curve-key-api"><a class="header" href="#basic-elliptic-curve-key-api">Basic Elliptic Curve Key API</a></h2>
<hr />
<h3 id="eckey"><a class="header" href="#eckey"><strong>eckey:</strong></a></h3>
<pre><code>typedef struct eckey {
    int idx;
    dogecoin_key private_key;
    char private_key_wif[PRIVKEYWIFLEN];
    dogecoin_pubkey public_key;
    char public_key_hex[PUBKEYHEXLEN];
    char address[P2PKHLEN];
    UT_hash_handle hh;
} eckey;
</code></pre>
<hr />
<h3 id="keys"><a class="header" href="#keys"><strong>keys:</strong></a></h3>
<pre><code>static eckey *keys = NULL;
</code></pre>
<p>This is an empty collection of key structures and meant for internal consumption.</p>
<hr />
<h3 id="new_eckey"><a class="header" href="#new_eckey"><strong>new_eckey:</strong></a></h3>
<pre><code class="language-c">eckey* new_eckey(dogecoin_bool is_testnet) {
    eckey* key = (struct eckey*)dogecoin_calloc(1, sizeof *key);
    dogecoin_privkey_init(&amp;key-&gt;private_key);
    assert(dogecoin_privkey_is_valid(&amp;key-&gt;private_key) == 0);
    dogecoin_privkey_gen(&amp;key-&gt;private_key);
    assert(dogecoin_privkey_is_valid(&amp;key-&gt;private_key)==1);
    dogecoin_pubkey_init(&amp;key-&gt;public_key);
    dogecoin_pubkey_from_key(&amp;key-&gt;private_key, &amp;key-&gt;public_key);
    assert(dogecoin_pubkey_is_valid(&amp;key-&gt;public_key) == 1);
    strcpy(key-&gt;public_key_hex, utils_uint8_to_hex((const uint8_t *)&amp;key-&gt;public_key, 33));
    uint8_t pkeybase58c[34];
    const dogecoin_chainparams* chain = is_testnet ? &amp;dogecoin_chainparams_test : &amp;dogecoin_chainparams_main;
    pkeybase58c[0] = chain-&gt;b58prefix_secret_address;
    pkeybase58c[33] = 1; /* always use compressed keys */
    memcpy_safe(&amp;pkeybase58c[1], &amp;key-&gt;private_key, DOGECOIN_ECKEY_PKEY_LENGTH);
    assert(dogecoin_base58_encode_check(pkeybase58c, sizeof(pkeybase58c), key-&gt;private_key_wif, sizeof(key-&gt;private_key_wif)) != 0);
    if (!dogecoin_pubkey_getaddr_p2pkh(&amp;key-&gt;public_key, chain, (char*)&amp;key-&gt;address)) return false;
    key-&gt;idx = HASH_COUNT(keys) + 1;
    return key;
}
</code></pre>
<p>This function instantiates a new working key, but does not add it to the hash table.</p>
<p><em>C usage:</em></p>
<pre><code class="language-c">eckey* key = new_eckey(false);
</code></pre>
<hr />
<h3 id="new_eckey_from_privkey"><a class="header" href="#new_eckey_from_privkey"><strong>new_eckey_from_privkey:</strong></a></h3>
<pre><code class="language-c">eckey* new_eckey_from_privkey(char* private_key) {
    eckey* key = (struct eckey*)dogecoin_calloc(1, sizeof *key);
    dogecoin_privkey_init(&amp;key-&gt;private_key);
    const dogecoin_chainparams* chain = chain_from_b58_prefix(private_key);
    if (!dogecoin_privkey_decode_wif(private_key, chain, &amp;key-&gt;private_key)) return false;
    assert(dogecoin_privkey_is_valid(&amp;key-&gt;private_key)==1);
    dogecoin_pubkey_init(&amp;key-&gt;public_key);
    dogecoin_pubkey_from_key(&amp;key-&gt;private_key, &amp;key-&gt;public_key);
    assert(dogecoin_pubkey_is_valid(&amp;key-&gt;public_key) == 1);
    strcpy(key-&gt;public_key_hex, utils_uint8_to_hex((const uint8_t *)&amp;key-&gt;public_key, 33));
    uint8_t pkeybase58c[34];
    pkeybase58c[0] = chain-&gt;b58prefix_secret_address;
    pkeybase58c[33] = 1; /* always use compressed keys */
    memcpy_safe(&amp;pkeybase58c[1], &amp;key-&gt;private_key, DOGECOIN_ECKEY_PKEY_LENGTH);
    assert(dogecoin_base58_encode_check(pkeybase58c, sizeof(pkeybase58c), key-&gt;private_key_wif, sizeof(key-&gt;private_key_wif)) != 0);
    if (!dogecoin_pubkey_getaddr_p2pkh(&amp;key-&gt;public_key, chain, (char*)&amp;key-&gt;address)) return false;
    key-&gt;idx = HASH_COUNT(keys) + 1;
    return key;
}
</code></pre>
<p>This function instantiates a new working key from a <code>private_key</code> in WIF format, but does not add it to the hash table.</p>
<p><em>C usage:</em></p>
<pre><code class="language-c">char* privkey = "QUtnMFjt3JFk1NfeMe6Dj5u4p25DHZA54FsvEFAiQxcNP4bZkPu2";
eckey* key = new_eckey_from_privkey(privkey);
...

dogecoin_free(key);
</code></pre>
<hr />
<h3 id="add_eckey"><a class="header" href="#add_eckey"><strong>add_eckey:</strong></a></h3>
<pre><code class="language-c">void add_eckey(eckey *key) {
    eckey* key_old;
    HASH_FIND_INT(keys, &amp;key-&gt;idx, key_old);
    if (key_old == NULL) {
        HASH_ADD_INT(keys, idx, key);
    } else {
        HASH_REPLACE_INT(keys, idx, key, key_old);
    }
    dogecoin_free(key_old);
}
</code></pre>
<p>This function takes a pointer to an existing working eckey object and adds it to the hash table.</p>
<p><em>C usage:</em></p>
<pre><code class="language-c">eckey* key = new_eckey(false);
add_eckey(key);
</code></pre>
<hr />
<h3 id="start_key"><a class="header" href="#start_key"><strong>start_key:</strong></a></h3>
<pre><code class="language-c">int start_key(dogecoin_bool is_testnet) {
    eckey* key = new_eckey(is_testnet);
    int index = key-&gt;idx;
    add_eckey(key);
    return index;
}
</code></pre>
<p>This function creates a new eckey, places it in the hash table, and returns the index of the new eckey, starting from 1 and incrementing each subsequent call.</p>
<p><em>C usage:</em></p>
<pre><code class="language-c">int key_id = start_key(false);
</code></pre>
<hr />
<h3 id="find_eckey"><a class="header" href="#find_eckey"><strong>find_eckey:</strong></a></h3>
<pre><code class="language-c">eckey* find_eckey(int idx) {
    eckey* key;
    HASH_FIND_INT(keys, &amp;idx, key);
    return key;
}
</code></pre>
<p>This function takes an index and returns the working eckey associated with that index in the hash table.</p>
<p><em>C usage:</em></p>
<pre><code class="language-c">...
int key_id = start_key(false);
eckey* key = find_eckey(key_id);
...
</code></pre>
<hr />
<h3 id="remove_eckey"><a class="header" href="#remove_eckey"><strong>remove_eckey:</strong></a></h3>
<pre><code class="language-c">void remove_eckey(eckey* key) {
    HASH_DEL(keys, key); /* delete it (keys advances to next) */
    dogecoin_privkey_cleanse(&amp;key-&gt;private_key);
    dogecoin_pubkey_cleanse(&amp;key-&gt;public_key);
    dogecoin_key_free(key);
}
</code></pre>
<p>This function removes the specified working eckey from the hash table and frees the eckey in memory.</p>
<p><em>C usage:</em></p>
<pre><code class="language-c">int key_id = start_key(false);
eckey* key = find_eckey(key_id);
remove_eckey(key)
</code></pre>
<hr />
<h3 id="dogecoin_key_free"><a class="header" href="#dogecoin_key_free"><strong>dogecoin_key_free:</strong></a></h3>
<pre><code class="language-c">void dogecoin_key_free(eckey* eckey)
{
    dogecoin_free(eckey);
}
</code></pre>
<p>This function frees the memory allocated for an eckey.</p>
<p><em>C usage:</em></p>
<pre><code class="language-c">...
dogecoin_key_free(key);
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secure-enclaves-integration-with-libdogecoin"><a class="header" href="#secure-enclaves-integration-with-libdogecoin">Secure Enclaves Integration with libdogecoin</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>This document discusses our research on enhancing the security of <strong>libdogecoin</strong> key management operations using <strong>Intel SGX</strong> and <strong>ARM TrustZone</strong> as secure enclaves. By performing key management within secure enclaves, we significantly reduce the risk of key exposure, thereby increasing the overall security of Dogecoin transactions. This document includes an overview of the research, build instructions for the key management enclaves, and a step-by-step tutorial on using the host command line interface to interact with the enclaves in both <strong>OP-TEE</strong> and <strong>OpenEnclave</strong> environments. Additionally, we outline critical vulnerabilities in Trusted Execution Environments (TEEs) and provide recommendations for mitigating these risks.</p>
<p>This document covers mnemonic generation, public key derivation, address generation, message signing, and transaction signing as part of secure enclave operations.</p>
<h2 id="what-are-secure-enclaves"><a class="header" href="#what-are-secure-enclaves">What are Secure Enclaves?</a></h2>
<p>Secure enclaves are isolated environments that provide a secure space for sensitive operations. These enclaves are isolated from the rest of the system, ensuring that sensitive data and operations are protected from unauthorized access. <strong>Secure enclaves</strong> within a processor can be implemented using different technologies such as <strong>TEEs</strong>, hardware security modules (<strong>HSMs</strong>), and virtualization-based solutions. To ensure a robust defense, secure enclaves must guarantee <strong>confidentiality</strong>, <strong>integrity</strong>, and <strong>availability</strong> for sensitive operations. However, enclaves are not a silver bullet and must be integrated within a broader security strategy.</p>
<p>Compared to hardware security modules (HSMs) and trusted platform modules (TPMs), secure enclaves provide in-CPU isolation, which makes them ideal for high-performance cryptographic operations without requiring external hardware.</p>
<h2 id="why-use-secure-enclaves"><a class="header" href="#why-use-secure-enclaves">Why Use Secure Enclaves?</a></h2>
<p>Secure enclaves offer several advantages for key management operations:</p>
<ul>
<li><strong>Isolation</strong>: Enclaves provide a secure environment that is isolated from the rest of the system, protecting sensitive data and operations.</li>
<li><strong>Confidentiality</strong>: Enclaves ensure that sensitive data is encrypted and protected from unauthorized access.</li>
<li><strong>Integrity</strong>: Enclaves guarantee the integrity of sensitive operations, ensuring that they have not been tampered with.</li>
<li><strong>Remote Attestation</strong>: Enclaves can be remotely attested to verify their integrity and authenticity to external parties.</li>
<li><strong>Key Management</strong>: Enclaves can securely generate, store, and manage cryptographic keys, protecting them from unauthorized access.</li>
</ul>
<p>By performing key operations within secure enclaves, developers can enhance the security of their applications and protect sensitive data from unauthorized access.</p>
<h2 id="secure-enclaves-in-libdogecoin"><a class="header" href="#secure-enclaves-in-libdogecoin">Secure Enclaves in libdogecoin</a></h2>
<h3 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h3>
<p>In this section, we define some key concepts central to secure enclaves and their implementation.</p>
<ul>
<li><strong>Host</strong>: The normal world that interacts with the enclave.</li>
<li><strong>Enclave</strong>: The secure world within the CPU where sensitive operations are performed.</li>
<li><strong>Trusted Execution Environment (TEE)</strong>: A hardware-based secure environment that protects sensitive operations from external interference and tampering.</li>
<li><strong>ECALLS</strong>: Enclave calls used in <strong>OpenEnclave</strong> that allow the host to interact with the secure enclave.</li>
<li><strong>SMCs</strong>: Secure Monitor Calls that manage communication between the normal and secure worlds in <strong>ARM TrustZone</strong>.</li>
<li><strong>Remote Attestation</strong>: The process of verifying the integrity and authenticity of an enclave to a remote party.</li>
</ul>
<p>By performing key operations such as <strong>seedphrase generation</strong>, <strong>public key derivation</strong>, and <strong>message and transaction signing</strong> within these enclaves, we can greatly reduce the risk of private key exposure, even in the event of a host system compromise.</p>
<h2 id="what-are-trusted-execution-environments-tees"><a class="header" href="#what-are-trusted-execution-environments-tees">What are Trusted Execution Environments (TEEs)?</a></h2>
<p>TEEs are secure environments within a processor that provide a trusted execution domain for sensitive operations. They ensure that sensitive data and operations are protected from unauthorized access and tampering. TEEs can be implemented using hardware-based security technologies such as <strong>Intel SGX</strong>, <strong>ARM TrustZone</strong>, or other vendor-specific technologies. While they offer significant advantages in terms of isolating critical operations, TEEs also come with their own set of challenges, particularly in terms of addressing vulnerabilities and maintaining performance.</p>
<h3 id="contrast-between-intel-sgx-and-arm-trustzone"><a class="header" href="#contrast-between-intel-sgx-and-arm-trustzone">Contrast Between Intel SGX and ARM TrustZone</a></h3>
<div class="table-wrapper"><table><thead><tr><th><strong>Criteria</strong></th><th><strong>Intel SGX (OpenEnclave)</strong></th><th><strong>ARM TrustZone (OP-TEE)</strong></th></tr></thead><tbody>
<tr><td><strong>Target Platform</strong></td><td>Primarily x86 server-class CPUs</td><td>Primarily ARM mobile and embedded devices</td></tr>
<tr><td><strong>Security Model</strong></td><td>Memory encryption and isolated execution</td><td>Secure world execution isolated from normal world</td></tr>
<tr><td><strong>Key Vulnerabilities</strong></td><td>Foreshadow, Plundervolt, SGAxe</td><td>CVE-2021-34387, CVE-2020-16273</td></tr>
<tr><td><strong>Performance Overhead</strong></td><td>Higher, especially for I/O and large memory use</td><td>Lower, better for embedded and mobile devices</td></tr>
<tr><td><strong>Use Cases</strong></td><td>Server applications, enterprise security</td><td>IoT, mobile devices, embedded systems</td></tr>
</tbody></table>
</div>
<h2 id="hardware-and-software"><a class="header" href="#hardware-and-software">Hardware and Software</a></h2>
<h3 id="intel-sgx-and-openenclave"><a class="header" href="#intel-sgx-and-openenclave">Intel SGX and OpenEnclave</a></h3>
<p>Intel SGX (Software Guard Extensions) is a hardware-based security technology that creates isolated TEEs within some Intel CPUs. OpenEnclave is an open-source SDK that enables developers to build host and enclave applications that run on Intel SGX. SGX works by partitioning secure memory regions within the CPU that are isolated from the rest of the system, ensuring that sensitive data is protected from unauthorized access. These memory regions are encrypted and authenticated, providing a secure environment for cryptographic operations.</p>
<p>OpenEnclave offers an interface for developing applications that run within SGX enclaves, enabling developers to build secure applications that protect sensitive data and operations. The host interacts with the enclave using ECALLS, allowing the enclave to perform cryptographic operations securely. Remote attestation is used to verify the integrity of the enclave to remote parties, ensuring that the enclave has not been tampered with.</p>
<h3 id="arm-trustzone-and-op-tee"><a class="header" href="#arm-trustzone-and-op-tee">ARM TrustZone and OP-TEE</a></h3>
<p>ARM TrustZone is another hardware-based security technology that creates TEEs within ARM CPUs. OP-TEE (Open Portable Trusted Execution Environment) is an open-source software framework that facilitates the development of applications running within ARM TrustZone enclaves. TrustZone creates a secure world and a normal world within the CPU, isolating sensitive operations from the rest of the system. The processor switches between the secure and normal worlds, ensuring that sensitive operations are performed securely. Memory is partitioned between the secure and normal worlds using page tables, protecting sensitive data from unauthorized access.</p>
<p>OP-TEE provides a secure world OS for cryptographic operations in TrustZone firmware, ensuring that private keys and sensitive data are protected from unauthorized access. The host interacts with the secure world using SMCs, allowing the secure enclave to perform cryptographic operations securely. OP-TEE is widely used in IoT devices, mobile phones, and embedded systems to protect sensitive data and operations.</p>
<h2 id="key-management-enclaves"><a class="header" href="#key-management-enclaves">Key Management Enclaves</a></h2>
<h3 id="visual-representation-simplified"><a class="header" href="#visual-representation-simplified">Visual Representation (Simplified)</a></h3>
<pre><code class="language-text">+-----------------------------------------+               +-----------------------------------------+
| Host                                    |               | Host                                    |
|                                         |               |                                         |
|  +-----------------------------------+  |               |  +-----------------------------------+  |
|  |      command line interface       |  |               |  |      command line interface       |  |
|  |                                   |  |               |  |                                   |  |
|  |  +-----------------------------+  |  |               |  |  +-----------------------------+  |  |
|  |  |         libdogecoin         |  |  |               |  |  |         libdogecoin         |  |  |
|  +-----------------------------------+  |               |  +-----------------------------------+  |
|  |         OpenEnclave Host          |  |               |  |           OP-TEE Client           |  |
+-----------------------------------------+               +-----------------------------------------+
|                Linux OS                 |               |                Linux OS                 |
+-----------------------------------------+               +-----------------------------------------+
| Enclave            ^                    |               | Enclave            ^                    |
|                 ECALLS                  |               |                   SMCs                  |
|                    |                    |               |                    |                    |
|        Messages and Transactions        |               |        Messages and Transactions        |
|        Public Keys and Addresses        |               |        Public Keys and Addresses        |
|                    |                    |               |                    |                    |
|                    v                    |               |                    v                    |
|  +-----------------------------------+  |               |  +-----------------------------------+  |
|  |          Key Management           |  |               |  |          Key Management           |  |
|  |  - Seedphrase Generation          |  |               |  |  - Seedphrase Generation          |  |
|  |  - Public Key Generation          |  |               |  |  - Public Key Generation          |  |
|  |  - Address Generation             |  |               |  |  - Address Generation             |  |
|  |  - Sign Message                   |  |               |  |  - Sign Message                   |  |
|  |  - Sign Transaction               |  |               |  |  - Sign Transaction               |  |
|  |                                   |  |               |  |                                   |  |
|  |  +-----------------------------+  |  |               |  |  +-----------------------------+  |  |
|  |  |         libdogecoin         |  |  |               |  |  |         libdogecoin         |  |  |
+-----------------------------------------+               +-----------------------------------------+
|              OpenEnclave                |               |       OP-TEE OS + Trusted Firmware      |
+-----------------------------------------+               +-----------------------------------------+
|               Intel SGX                 |               |             ARMv8 TrustZone             |
+-----------------------------------------+               +-----------------------------------------+
</code></pre>
<h3 id="key-management-operations"><a class="header" href="#key-management-operations">Key Management Operations</a></h3>
<p>The secure enclave handles the following operations:</p>
<ul>
<li><strong>Seedphrase Generation</strong>: Protecting the creation of seedphrases for wallet recovery.</li>
<li><strong>Public Key Generation</strong>: Deriving public keys in the enclave, ensuring private keys are never exposed.</li>
<li><strong>Address Generation</strong>: Generating secure Dogecoin addresses within the enclave.</li>
<li><strong>Sign Message/Transaction</strong>: Ensuring the integrity and authenticity of signed messages and transactions.</li>
</ul>
<h3 id="limitations-and-assumptions"><a class="header" href="#limitations-and-assumptions">Limitations and Assumptions</a></h3>
<p>While secure enclaves provide powerful protection, they are <strong>not infallible</strong>. The <strong>Foreshadow</strong> vulnerability is a good example of how attackers can bypass enclave protections. Furthermore, the security model assumes that the host environment is insecure, relying entirely on the enclave for protection. Developers should adopt a <strong>defense-in-depth</strong> strategy, using <strong>secure coding practices</strong> and <strong>regular security audits</strong> to complement enclave security.</p>
<h3 id="performance-trade-offs"><a class="header" href="#performance-trade-offs">Performance trade-offs</a></h3>
<p>Secure enclaves introduce performance overhead due to the encryption and isolation mechanisms they employ. For example, <strong>Intel SGX</strong> enclaves have higher performance overhead compared to <strong>ARM TrustZone</strong> enclaves, especially for I/O and large memory use. <strong>ARM TrustZone</strong> enclaves are better suited for embedded and mobile devices due to their lower performance impact. However key management operations are typically not performance-critical, making secure enclave protection a worthwhile trade-off for the increased security it provides.</p>
<h3 id="secure-storage"><a class="header" href="#secure-storage">Secure Storage</a></h3>
<p>Mnemonic seedphrases are securely encrypted by the enclave to prevent unauthorized access. Encrypted data should still be backed up using the <strong>rule of three</strong>: store copies in three distinct locations to ensure recovery.</p>
<h3 id="time-based-one-time-password-totp-authentication"><a class="header" href="#time-based-one-time-password-totp-authentication">Time-Based One-Time Password (TOTP) Authentication</a></h3>
<p>TOTP authentication using a <strong>YubiKey</strong> further enhances security by ensuring that access to sensitive enclave operations is restricted to authorized users. When combined with password-based authentication, TOTP provides an additional layer of security. This two-factor authentication approach increases security during enclave operations, preventing unauthorized key usage even if the host environment is compromised.</p>
<h2 id="future-research"><a class="header" href="#future-research">Future Research</a></h2>
<p>To further improve the security and functionality of Dogecoin’s ecosystem, we recommend exploring <strong>Remote Attestation</strong> to validate the integrity of enclaves in distributed systems. This would allow external parties to verify the authenticity of enclaves, ensuring that they have not been tampered with. Intel SGX supports remote attestation, while ARM TrustZone can be extended to include this feature.</p>
<p>Performance optimizations for secure enclaves are another area of interest, as reducing overhead can make enclaves more practical for a wider range of applications. Additonal analysis is needed to evaluate the performance impact of secure enclaves on key management operations at scale.</p>
<p>Additionally, alternative secure technologies like <strong>AMD SEV</strong> and <strong>RISC-V</strong> should be explored to broaden the options available for TEE-based applications. These technologies offer different security models and performance characteristics that may be better suited to specific use cases.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://software.intel.com/en-us/sgx">Intel SGX</a></li>
<li><a href="https://www.arm.com/solutions/security-on-arm/trustzone">ARM TrustZone</a></li>
<li><a href="https://www.openenclave.io/">OpenEnclave</a></li>
<li><a href="https://optee.readthedocs.io/en/latest/">OP-TEE</a></li>
</ul>
<h2 id="tee-vulnerabilities"><a class="header" href="#tee-vulnerabilities">TEE Vulnerabilities</a></h2>
<p>It is crucial to keep systems up-to-date with the latest security fixes and patches to mitigate the risks associated with any vulnerabilities. Regularly applying security patches and following best practices for secure enclave development can help protect sensitive data and operations. Below are some recent vulnerabilities that have been discovered in Intel SGX, ARM TrustZone, OpenEnclave, and OP-TEE. It is essential to stay informed about these vulnerabilities and take appropriate measures to address them.</p>
<p><strong>Intel SGX:</strong>
Several vulnerabilities have been discovered in Intel SGX:</p>
<ol>
<li>
<p><strong>Foreshadow (CVE-2018-3615):</strong> This vulnerability allows attackers to access sensitive information stored in SGX enclaves. Details can be found in the <a href="https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00161.html">Intel Security Advisory</a>.</p>
</li>
<li>
<p><strong>Plundervolt (CVE-2019-11157):</strong> This vulnerability exploits the CPU's undervolting features to breach SGX enclave protections. More information is available in the <a href="https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00289.html">Intel Security Advisory</a>.</p>
</li>
<li>
<p><strong>SGAxe (CVE-2020-0551):</strong> This vulnerability allows side-channel attacks to extract sensitive information from SGX enclaves. Refer to the <a href="https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00334.html">Intel Security Advisory</a> for further details.</p>
</li>
</ol>
<p><strong>ARM TrustZone:</strong>
While many vulnerabilities related to ARM TrustZone tend to be vendor-specific or related to specific implementations, the core TrustZone architecture itself has also been associated with certain security concerns. Below are examples of both types:</p>
<ol>
<li>
<p><strong>CVE-2021-34387:</strong> This vulnerability in the ARM TrustZone technology, on which Trusty is based, allows unauthorized write access to kernel code and data that is mapped as read-only, affecting the DRAM reserved for TrustZone. Further details can be found <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-34387">here</a>.</p>
</li>
<li>
<p><strong>CVE-2021-33478:</strong> This issue affects Broadcom MediaxChange firmware, potentially allowing an unauthenticated attacker to achieve arbitrary code execution in the TrustZone TEE of an affected device. More information is available <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-33478">here</a>.</p>
</li>
<li>
<p><strong>CVE-2021-29415:</strong> This vulnerability involves the ARM TrustZone CryptoCell 310 in Nordic Semiconductor nRF52840, allowing adversaries to recover private ECC keys during ECDSA operations. Details can be found <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-29415">here</a>.</p>
</li>
<li>
<p><strong>CVE-2020-16273:</strong> This vulnerability in ARMv8-M processors' software stack selection mechanism can be exploited by a stack-underflow attack, allowing changes to the stack pointer from a non-secure application. More information is available <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-16273">here</a>.</p>
</li>
<li>
<p><strong>CVE-2022-47549:</strong> This issue in OP-TEE, which is closely associated with ARM TrustZone, allows bypassing signature verification and installing malicious trusted applications via electromagnetic fault injections. More details are available <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-47549">here</a>.</p>
</li>
</ol>
<p>It's important to recognize that while TrustZone provides a secure environment, its effectiveness is heavily dependent on how it is implemented and integrated with other system components. Architectural issues or specific use-case vulnerabilities may arise, emphasizing the need for rigorous security practices.</p>
<p><strong>OpenEnclave:</strong>
For vulnerabilities and security advisories related to OpenEnclave, refer to their <a href="https://github.com/openenclave/openenclave/security">GitHub security page</a>.</p>
<p><strong>OP-TEE:</strong>
For vulnerabilities and security advisories related to OP-TEE, refer to their <a href="https://github.com/OP-TEE/optee_os/security">GitHub security page</a>.</p>
<p>To mitigate the risks associated with these vulnerabilities, it is essential to stay informed about the latest security advisories and best practices for secure enclave development. Regularly applying security patches and following secure coding practices can help protect sensitive data and operations from unauthorized access.</p>
<h2 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h2>
<p>Enclaves are not a silver bullet. As a risk mitigation measure, enclaves can provide significant benefits in protecting sensitive data and operations. We encourage developers to explore secure enclaves and their potential benefits, but caution that they should be used as part of a comprehensive security strategy that includes other security measures such as secure coding practices and audits. Enclaves are not immune to vulnerabilities, and it is essential to stay informed about the latest security advisories and best practices for secure enclave development.</p>
<h2 id="build-instructions"><a class="header" href="#build-instructions">Build Instructions</a></h2>
<h3 id="building-op-tee-sdk-and-client"><a class="header" href="#building-op-tee-sdk-and-client">Building OP-TEE SDK and Client</a></h3>
<p><strong>Dependencies</strong></p>
<ul>
<li>Ubuntu 20.04 or later</li>
<li>Docker</li>
<li>Libdogecoin</li>
</ul>
<pre><code class="language-sh">sudo apt-get install docker.io

mkdir -p /doge
cd /doge
git clone https://github.com/dogecoinfoundation/libdogecoin.git
cd libdogecoin
</code></pre>
<p>The SDK has several components and requires over 10GB of disk space to build. The build process can take over 30 minutes on a modern machine. Docker is used to build the SDK and client in a clean environment.</p>
<h3 id="step-1-nanopc-building-op-tee-sdk-and-client"><a class="header" href="#step-1-nanopc-building-op-tee-sdk-and-client">Step 1 (NanoPC): Building OP-TEE SDK and Client</a></h3>
<p>This command builds the latest SDK and client for NanoPC-T6 (nanopc-t6.xml).  When complete, the image will be located in <code>/doge/libdogecoin/optee/out/nanopc-t6.img</code>. Burn this image to an SD card to boot the NanoPC-T6. Connect an Ethernet cable, USB keyboard and HDMI to the NanoPC-T6 and power it on. The default IP address is configured using DHCP. Login as root via ssh (e.g. <code>ssh root@192.168.137.19</code>) or using the HDMI console.</p>
<p><code>LINUX_MODULES=y</code> is used to build the Linux kernel modules. The <code>CFG_TEE_CORE_LOG_LEVEL=0</code> environment variable sets the log level to 0 (no logging). The <code>CFG_ATTESTATION_PTA=y</code> environment variable enables the attestation PTA. The <code>CFG_ATTESTATION_PTA_KEY_SIZE=1024</code> environment variable sets the attestation PTA key size to 1024 bits. The <code>CFG_WITH_USER_TA=y</code> environment variable enables user TAs. The <code>CFG_WITH_SOFTWARE_PRNG=n</code> environment variable enables the hardware PRNG.</p>
<p>An RSA private key is generated and overwrites the default Trusted Application (TA) key. This key is used to sign the enclave binaries during development. In the Continuous Integration (CI) environment, an Actions secret is used. Subkeys are generated for testing purposes but are not used to sign the enclave binaries.</p>
<pre><code class="language-sh">docker pull jforissier/optee_os_ci:qemu_check
docker run -v "$(pwd):/src" -w /src jforissier/optee_os_ci:qemu_check /bin/bash -c "\
    # Set up the environment and build the OP-TEE SDK
    set -e &amp;&amp; \
    apt update &amp;&amp; \
    apt -y upgrade &amp;&amp; \
    apt -y install libusb-1.0-0-dev swig python3-dev python3-setuptools e2tools &amp;&amp; \
    curl https://storage.googleapis.com/git-repo-downloads/repo &gt; /bin/repo &amp;&amp; chmod a+x /bin/repo &amp;&amp; \
    mkdir -p optee &amp;&amp; \
    cd optee &amp;&amp; \
    # repo init -u https://github.com/OP-TEE/manifest.git -m qemu_v8.xml -b 4.0.0
    repo init -u https://github.com/OP-TEE/manifest.git -m nanopc-t6.xml -b master &amp;&amp; \
    export FORCE_UNSAFE_CONFIGURE=1 &amp;&amp; \
    repo sync -j 4 --force-sync &amp;&amp; \
    cd build &amp;&amp; \
    make toolchains -j 4 &amp;&amp; \
    export CFG_TEE_CORE_LOG_LEVEL=0 &amp;&amp; \
    export CFG_ATTESTATION_PTA=y &amp;&amp; \
    export CFG_ATTESTATION_PTA_KEY_SIZE=1024 &amp;&amp; \
    export CFG_WITH_USER_TA=y &amp;&amp; \
    export CFG_WITH_SOFTWARE_PRNG=n &amp;&amp; \

    # Generate RSA private key and overwrite the default TA key
    openssl genpkey -algorithm RSA -out rsa_private.pem -pkeyopt rsa_keygen_bits:2048 &amp;&amp; \
    mv rsa_private.pem /src/optee/optee_os/keys/default_ta.pem &amp;&amp; \

    # Generate subkeys
    openssl genrsa -out /src/optee/optee_test/ta/top_level_subkey.pem &amp;&amp; \
    openssl genrsa -out /src/optee/optee_test/ta/mid_level_subkey.pem &amp;&amp; \
    openssl genrsa -out /src/optee/optee_test/ta/identity_subkey2.pem &amp;&amp; \

    # Sign the top-level subkey with the root key
    /src/optee/optee_os/scripts/sign_encrypt.py sign-subkey \
        --uuid f04fa996-148a-453c-b037-1dcfbad120a6 \
        --key /src/optee/optee_os/keys/default_ta.pem --in /src/optee/optee_test/ta/top_level_subkey.pem \
        --out /src/optee/optee_test/ta/top_level_subkey.bin --max-depth 4 --name-size 64 \
        --subkey-version 1 &amp;&amp; \

    # Generate UUID for the mid-level subkey
    /src/optee/optee_os/scripts/sign_encrypt.py subkey-uuid --in /src/optee/optee_test/ta/top_level_subkey.bin \
        --name mid_level_subkey &amp;&amp; \

    # Sign the mid-level subkey with the top-level subkey
    /src/optee/optee_os/scripts/sign_encrypt.py sign-subkey \
        --uuid 1a5948c5-1aa0-518c-86f4-be6f6a057b16 \
        --key /src/optee/optee_test/ta/top_level_subkey.pem --subkey /src/optee/optee_test/ta/top_level_subkey.bin \
        --name-size 64 --subkey-version 1 \
        --name mid_level_subkey \
        --in /src/optee/optee_test/ta/mid_level_subkey.pem --out /src/optee/optee_test/ta/mid_level_subkey.bin &amp;&amp; \

    # Generate UUID for subkey1_ta
    /src/optee/optee_os/scripts/sign_encrypt.py subkey-uuid --in /src/optee/optee_test/ta/mid_level_subkey.bin \
        --name subkey1_ta &amp;&amp; \

    # Sign the identity subkey2 with the root key
    /src/optee/optee_os/scripts/sign_encrypt.py sign-subkey \
        --uuid a720ccbb-51da-417d-b82e-e5445d474a7a \
        --key /src/optee/optee_os/keys/default_ta.pem --in /src/optee/optee_test/ta/identity_subkey2.pem \
        --out /src/optee/optee_test/ta/identity_subkey2.bin --max-depth 0 --name-size 0 \
        --subkey-version 1 &amp;&amp; \

    # Build and test the OP-TEE OS and client
    # make -j 4 check
    make LINUX_MODULES=y -j 4 &amp;&amp; \
    cd /src &amp;&amp; \
    [ ! -d optee_client ] &amp;&amp; git clone https://github.com/OP-TEE/optee_client.git &amp;&amp; \
    cd optee_client &amp;&amp; \
    mkdir -p build &amp;&amp; \
    cd build &amp;&amp; \
    export PATH=/src/optee/toolchains/aarch64/bin:$PATH &amp;&amp; \
    export CC=aarch64-linux-gnu-gcc &amp;&amp; \
    cmake .. -DCMAKE_C_COMPILER=aarch64-linux-gnu-gcc -DCMAKE_INSTALL_PREFIX=/src/optee/toolchains/aarch64 &amp;&amp; \
    make -j 4 VERBOSE=1 &amp;&amp; \
    make install"
</code></pre>
<h3 id="step-1-qemu-building-op-tee-sdk-and-client"><a class="header" href="#step-1-qemu-building-op-tee-sdk-and-client">Step 1 (QEMU): Building OP-TEE SDK and Client</a></h3>
<p>This command builds the SDK (version 4.0.0) and client for ARMv8 QEMU emulation (qemu_v8.xml). For other platforms, change the manifest file in the <code>repo init</code> command accordingly. Replace <code>4.0.0</code> with the desired version and <code>qemu_v8.xml</code> with the desired platform. Refer to the <a href="https://optee.readthedocs.io/en/latest/building/index.html">OP-TEE documentation</a> for more information.</p>
<pre><code class="language-sh">docker pull jforissier/optee_os_ci:qemu_check
docker run -v "$(pwd):/src" -w /src jforissier/optee_os_ci:qemu_check /bin/bash -c "\
    # Set up the environment and build the OP-TEE SDK
    set -e &amp;&amp; \
    apt update &amp;&amp; \
    apt -y upgrade &amp;&amp; \
    apt -y install libusb-1.0-0-dev swig python3-dev python3-setuptools e2tools &amp;&amp; \
    curl https://storage.googleapis.com/git-repo-downloads/repo &gt; /bin/repo &amp;&amp; chmod a+x /bin/repo &amp;&amp; \
    mkdir -p optee &amp;&amp; \
    cd optee &amp;&amp; \
    repo init -u https://github.com/OP-TEE/manifest.git -m qemu_v8.xml -b 4.0.0 &amp;&amp; \
    export FORCE_UNSAFE_CONFIGURE=1 &amp;&amp; \
    repo sync -j 4 --force-sync &amp;&amp; \
    patch -N -F 4 /src/optee/build/common.mk &lt; /src/src/optee/common.mk.patch &amp;&amp; \
    cd build &amp;&amp; \
    make toolchains -j 4 &amp;&amp; \
    export CFG_TEE_CORE_LOG_LEVEL=0 &amp;&amp; \
    export CFG_ATTESTATION_PTA=y &amp;&amp; \
    export CFG_ATTESTATION_PTA_KEY_SIZE=1024 &amp;&amp; \
    export CFG_WITH_USER_TA=y &amp;&amp; \

    # Generate RSA private key and overwrite the default TA key
    openssl genpkey -algorithm RSA -out rsa_private.pem -pkeyopt rsa_keygen_bits:2048 &amp;&amp; \
    mv rsa_private.pem /src/optee/optee_os/keys/default_ta.pem &amp;&amp; \

    # Generate subkeys
    openssl genrsa -out /src/optee/optee_test/ta/top_level_subkey.pem &amp;&amp; \
    openssl genrsa -out /src/optee/optee_test/ta/mid_level_subkey.pem &amp;&amp; \
    openssl genrsa -out /src/optee/optee_test/ta/identity_subkey2.pem &amp;&amp; \

    # Sign the top-level subkey with the root key
    /src/optee/optee_os/scripts/sign_encrypt.py sign-subkey \
        --uuid f04fa996-148a-453c-b037-1dcfbad120a6 \
        --key /src/optee/optee_os/keys/default_ta.pem --in /src/optee/optee_test/ta/top_level_subkey.pem \
        --out /src/optee/optee_test/ta/top_level_subkey.bin --max-depth 4 --name-size 64 \
        --subkey-version 1 &amp;&amp; \

    # Generate UUID for the mid-level subkey
    /src/optee/optee_os/scripts/sign_encrypt.py subkey-uuid --in /src/optee/optee_test/ta/top_level_subkey.bin \
        --name mid_level_subkey &amp;&amp; \

    # Sign the mid-level subkey with the top-level subkey
    /src/optee/optee_os/scripts/sign_encrypt.py sign-subkey \
        --uuid 1a5948c5-1aa0-518c-86f4-be6f6a057b16 \
        --key /src/optee/optee_test/ta/top_level_subkey.pem --subkey /src/optee/optee_test/ta/top_level_subkey.bin \
        --name-size 64 --subkey-version 1 \
        --name mid_level_subkey \
        --in /src/optee/optee_test/ta/mid_level_subkey.pem --out /src/optee/optee_test/ta/mid_level_subkey.bin &amp;&amp; \

    # Generate UUID for subkey1_ta
    /src/optee/optee_os/scripts/sign_encrypt.py subkey-uuid --in /src/optee/optee_test/ta/mid_level_subkey.bin \
        --name subkey1_ta &amp;&amp; \

    # Sign the identity subkey2 with the root key
    /src/optee/optee_os/scripts/sign_encrypt.py sign-subkey \
        --uuid a720ccbb-51da-417d-b82e-e5445d474a7a \
        --key /src/optee/optee_os/keys/default_ta.pem --in /src/optee/optee_test/ta/identity_subkey2.pem \
        --out /src/optee/optee_test/ta/identity_subkey2.bin --max-depth 0 --name-size 0 \
        --subkey-version 1 &amp;&amp; \

    # Build and test the OP-TEE OS and client
    make -j 4 check
    cd /src &amp;&amp; \
    [ ! -d optee_client ] &amp;&amp; git clone https://github.com/OP-TEE/optee_client.git &amp;&amp; \
    cd optee_client &amp;&amp; \
    mkdir -p build &amp;&amp; \
    cd build &amp;&amp; \
    export PATH=/src/optee/toolchains/aarch64/bin:$PATH &amp;&amp; \
    export CC=aarch64-linux-gnu-gcc &amp;&amp; \
    cmake .. -DCMAKE_C_COMPILER=aarch64-linux-gnu-gcc -DCMAKE_INSTALL_PREFIX=/src/optee/toolchains/aarch64 &amp;&amp; \
    make -j 4 VERBOSE=1 &amp;&amp; \
    make install"
</code></pre>
<h3 id="step-2-qemu-or-nanopc-building-op-tee-libdogecoin-key-manager-enclave"><a class="header" href="#step-2-qemu-or-nanopc-building-op-tee-libdogecoin-key-manager-enclave">Step 2 (QEMU or NanoPC): Building OP-TEE Libdogecoin Key Manager Enclave</a></h3>
<p>This command builds the OP-TEE Libdogecoin Key Manager Enclave for QEMU ARMv8 or NanoPC-T6. The enclave is built using the OP-TEE SDK and client. The enclave binary is located in <code>/doge/libdogecoin/optee/out/bin/libdogecoin.img</code>.</p>
<p>Note that libdogecoin is built twice: once for the host and once for OP-TEE. The host build is used to build the host application, while the OP-TEE build is used to build the enclave. The CFLAGS=-Wp,-D_FORTIFY_SOURCE=0 flag is used to disable fortify source checks, which are not supported by OP-TEE.</p>
<pre><code class="language-sh">docker run --privileged -v "$(pwd):/src" -w /src jforissier/optee_os_ci:qemu_check /bin/bash -c "\
    # Set up the environment and build libdogecoin
    apt-get update &amp;&amp; \
    apt-get install -y autoconf automake libtool-bin build-essential curl python3 valgrind g++-aarch64-linux-gnu qemu-user-static qemu-user &amp;&amp; \

    # Build libdogecoin for Host
    make -j 4 -C depends HOST=aarch64-linux-gnu &amp;&amp; \
    ./autogen.sh &amp;&amp; \
    ./configure --prefix=/src/depends/aarch64-linux-gnu LIBS=-levent_pthreads --enable-static --disable-shared --enable-test-passwd HOST=aarch64-linux-gnu &amp;&amp; \
    make -j 4 &amp;&amp; \
    make install &amp;&amp; \

    export PATH=/src/optee/toolchains/aarch64/bin:$PATH &amp;&amp; \
    export CC=aarch64-linux-gnu-gcc &amp;&amp; \

    # Build the Host
    cd /src/src/optee/host &amp;&amp; \
    make -j 4 \
      CROSS_COMPILE=aarch64-linux-gnu- \
      LDFLAGS=\"-L/src/optee/toolchains/aarch64/lib -L/src/depends/aarch64-linux-gnu/lib -ldogecoin -lunistring\" \
      CFLAGS=\"-I/src/optee/toolchains/aarch64/include -I/src/src/optee/ta/include -I/src/depends/aarch64-linux-gnu/include -I/src/depends/aarch64-linux-gnu/include/ykpers-1 -I/src/depends/aarch64-linux-gnu/include/dogecoin\" &amp;&amp; \

    # Build libdogecoin for OP-TEE
    cd /src/ &amp;&amp; \
    make -j 4 -C depends CFLAGS=-Wp,-D_FORTIFY_SOURCE=0 HOST=aarch64-linux-gnu &amp;&amp; \
    ./configure --prefix=/src/depends/aarch64-linux-gnu LIBS=-levent_pthreads --enable-static --disable-shared --enable-test-passwd --enable-optee CFLAGS=-Wp,-D_FORTIFY_SOURCE=0 HOST=aarch64-linux-gnu &amp;&amp; \
    make -j 4 &amp;&amp; \
    make install &amp;&amp; \

    # Build the Enclave
    cd /src/src/optee/ta &amp;&amp; \
    make -j 4 \
      CROSS_COMPILE=aarch64-linux-gnu- \
      LIBDIR=/src/depends/aarch64-linux-gnu/lib \
      LDFLAGS=\"-L/src/depends/aarch64-linux-gnu/lib -ldogecoin -lunistring\" \
      CFLAGS=\"-I/src/depends/aarch64-linux-gnu/include -I/src/depends/aarch64-linux-gnu/include/dogecoin\" \
      PLATFORM=vexpress-qemu_armv8a \
      TA_DEV_KIT_DIR=/src/optee/optee_os/out/arm/export-ta_arm64 &amp;&amp; \

    # Create symbolic links and prepare image
    mkdir -p /src/optee/out/bin &amp;&amp; \
    cd /src/optee/out/bin &amp;&amp; \
    ln -sf ../../linux/arch/arm64/boot/Image Image &amp;&amp; \
    ln -sf ../../trusted-firmware-a/build/qemu/release/bl1.bin bl1.bin &amp;&amp; \
    ln -sf ../../trusted-firmware-a/build/qemu/release/bl2.bin bl2.bin &amp;&amp; \
    ln -sf ../../trusted-firmware-a/build/qemu/release/bl31.bin bl31.bin &amp;&amp; \
    ln -sf ../../optee_os/out/arm/core/tee-header_v2.bin bl32.bin &amp;&amp; \
    ln -sf ../../optee_os/out/arm/core/tee-pager_v2.bin bl32_extra1.bin &amp;&amp; \
    ln -sf ../../optee_os/out/arm/core/tee-pageable_v2.bin bl32_extra2.bin &amp;&amp; \
    ln -sf ../../edk2/Build/ArmVirtQemuKernel-AARCH64/RELEASE_GCC5/FV/QEMU_EFI.fd bl33.bin &amp;&amp; \
    ln -sf ../../out-br/images/rootfs.cpio.gz rootfs.cpio.gz &amp;&amp; \
    dd if=/dev/zero of=/src/optee/out/bin/libdogecoin.img bs=1M count=32 &amp;&amp; \
    mkfs.ext4 /src/optee/out/bin/libdogecoin.img &amp;&amp; \
    mkdir -p /src/optee/out-br/mnt &amp;&amp; \
    mount -o loop /src/optee/out/bin/libdogecoin.img /src/optee/out-br/mnt &amp;&amp; \
    cp /src/src/optee/ta/*.ta /src/optee/out-br/mnt &amp;&amp; \
    cp /src/src/optee/host/optee_libdogecoin /src/optee/out-br/mnt &amp;&amp; \
    cp /src/spvnode /src/optee/out-br/mnt &amp;&amp; \
    cp /src/sendtx /src/optee/out-br/mnt &amp;&amp; \
    cp /src/such /src/optee/out-br/mnt &amp;&amp; \
    cp /src/tests /src/optee/out-br/mnt &amp;&amp; \
    cp /src/bench /src/optee/out-br/mnt &amp;&amp; \
    mkdir -p /src/optee/out-br/mnt/data/tee &amp;&amp; \
    umount /src/optee/out-br/mnt &amp;&amp; \
    exit"
</code></pre>
<h3 id="step-3-nanopc-running-op-tee-libdogecoin-key-manager-enclave"><a class="header" href="#step-3-nanopc-running-op-tee-libdogecoin-key-manager-enclave">Step 3 (NanoPC): Running OP-TEE Libdogecoin Key Manager Enclave</a></h3>
<p>Use scp to copy the /doge/libdogecoin/optee/out/bin/libdogecoin.img to the NanoPC-T6 (e.g. <code>scp /doge/libdogecoin/optee/out/bin/libdogecoin.img root@192.168.137.19:/root/</code>). Then, SSH into the NanoPC-T6 and run the following commands:</p>
<pre><code class="language-sh">mkdir /media/libdogecoin
mount /root/libdogecoin.img /media/libdogecoin
cd /media/libdogecoin
cp /media/libdogecoin/62d95dc0-7fc2-4cb3-a7f3-c13ae4e633c4.ta /lib/optee_armtz/
./optee_libdogecoin -c generate_mnemonic
</code></pre>
<h3 id="step-3-qemu-running-op-tee-libdogecoin-key-manager-enclave"><a class="header" href="#step-3-qemu-running-op-tee-libdogecoin-key-manager-enclave">Step 3 (QEMU): Running OP-TEE Libdogecoin Key Manager Enclave</a></h3>
<pre><code class="language-sh">docker run --privileged -v /dev/bus/usb:/dev/bus/usb -it -v "$(pwd):/src" -w /src jforissier/optee_os_ci:qemu_check /bin/bash -c "\
  chmod 777 /src/optee/qemu/build/aarch64-softmmu/qemu-system-aarch64 &amp;&amp; \
  cd /src/optee/out/bin &amp;&amp; \
  /src/optee/qemu/build/aarch64-softmmu/qemu-system-aarch64 \
    -L /src/optee/qemu/pc-bios \
    -nographic \
    -serial mon:stdio \
    -serial file:/src/optee/serial1.log \
    -smp 2 \
    -machine virt,secure=on,mte=off,gic-version=3 \
    -cpu max,pauth-impdef=on \
    -d unimp \
    -semihosting-config enable=on,target=native \
    -m 1057 \
    -bios bl1.bin \
    -initrd rootfs.cpio.gz \
    -kernel Image \
    -no-acpi \
    -drive file=libdogecoin.img,format=raw,id=libdogecoin,if=none \
    -device virtio-blk-device,drive=libdogecoin \
    -append 'console=ttyAMA0,38400 keep_bootcon root=/dev/vda2' \
    -usb \
    -device pci-ohci,id=ohci \
    -device usb-host,vendorid=0x1050,productid=0x0407"
</code></pre>
<p><code>-v /dev/bus/usb:/dev/bus/usb</code> is used to pass the USB bus and YubiKey device to the container. The <code>-device usb-host,vendorid=0x1050,productid=0x0407</code> flag is used to pass the YubiKey to the QEMU VM. Replace <code>0x1050</code> and <code>0x0407</code> with the YubiKey's vendor and product IDs.</p>
<p>The QEMU ARMv8 emulator will boot the OP-TEE OS and Trusted Firmware, and the libdogecoin TA will be loaded into the enclave. The host application can then interact with the enclave to perform key management operations.</p>
<p>In the QEMU terminal, run the following commands to start the libdogecoin TA:</p>
<pre><code class="language-sh"># Mount the drive and copy the TA, host application, and data if needed
mkdir /mnt/libdogecoin &amp;&amp; \
mount /dev/vda /mnt/libdogecoin &amp;&amp; \
cp /mnt/libdogecoin/62d95dc0-7fc2-4cb3-a7f3-c13ae4e633c4.ta /lib/optee_armtz/ &amp;&amp; \
cp /mnt/libdogecoin/optee_libdogecoin /usr/bin/ &amp;&amp; \
if [ "$(ls -A /mnt/libdogecoin/data/tee/)" ]; then
  cp /mnt/libdogecoin/data/tee/* /data/tee/ &amp;&amp; \
  chown tee:tee /data/tee/*; \
fi
cd /usr/bin/ &amp;&amp; \
chmod 777 optee_libdogecoin
chmod 644 /lib/optee_armtz/62d95dc0-7fc2-4cb3-a7f3-c13ae4e633c4.ta

# Run the OP-TEE Libdogecoin Key Manager Enclave (see tutorial for commands)
optee_libdogecoin -c generate_mnemonic

# When finished, copy the data back to the drive
cp -r /data/tee/* /mnt/libdogecoin/data/tee/

# Unmount the drive and power off the system
umount /mnt/libdogecoin
poweroff
</code></pre>
<h3 id="building-openenclave-libdogecoin-key-manager-enclave"><a class="header" href="#building-openenclave-libdogecoin-key-manager-enclave">Building OpenEnclave Libdogecoin Key Manager Enclave</a></h3>
<p><strong>Dependencies</strong></p>
<ul>
<li>Ubuntu 20.04 or later</li>
<li>Docker</li>
<li>Libdogecoin</li>
</ul>
<pre><code class="language-sh">sudo apt-get install docker.io

mkdir -p /doge
cd /doge
git clone https://github.com/dogecoinfoundation/libdogecoin.git
cd libdogecoin
</code></pre>
<p>This command uses package installs for the OpenEnclave SDK and Docker to build the OpenEnclave Libdogecoin Key Manager Enclave. Docker is used to build the enclave in a clean environment. Refer to the <a href="https://github.com/openenclave/openenclave/blob/master/docs/GettingStartedDocs/Contributors/BuildingInADockerContainer.md">OpenEnclave documentation</a> for more information.</p>
<pre><code class="language-sh">docker run --device /dev/sgx_enclave:/dev/sgx_enclave --device /dev/sgx_provision:/dev/sgx_provision -it -v $PWD:/src -w /src ubuntu:20.04 bash -c "\
  # Set up the environment and build libdogecoin
  export DEBIAN_FRONTEND=noninteractive &amp;&amp; \
  apt-get update &amp;&amp; \
  apt-get install -y autoconf automake libtool-bin build-essential curl python3 valgrind python3-dev python3-dbg pkg-config &amp;&amp; \
  cd /src &amp;&amp; \

  # Build libdogecoin for Enclave
  make -j 4 -C depends HOST=x86_64-pc-linux-gnu &amp;&amp; \
  ./autogen.sh &amp;&amp; \
  ./configure --prefix=/src/depends/x86_64-pc-linux-gnu --enable-openenclave --enable-test-passwd CFLAGS=-Wp,-D_FORTIFY_SOURCE=0 &amp;&amp; \
  make &amp;&amp; \
  make install &amp;&amp; \

  # Build libdogecoin for Host
  make -j 4 -C depends HOST=x86_64-pc-linux-gnu/host &amp;&amp; \
  ./configure --prefix=/src/depends/x86_64-pc-linux-gnu/host --enable-test-passwd &amp;&amp; \
  make &amp;&amp; \
  make install &amp;&amp; \

  # Set up the OpenEnclave environment and build the enclave
  apt-get install -y wget gnupg2 cmake &amp;&amp; \
  echo 'deb [arch=amd64] https://download.01.org/intel-sgx/sgx_repo/ubuntu focal main' | tee /etc/apt/sources.list.d/intel-sgx.list &amp;&amp; \
  wget -qO - https://download.01.org/intel-sgx/sgx_repo/ubuntu/intel-sgx-deb.key | apt-key add - &amp;&amp; \
  echo 'deb http://apt.llvm.org/focal/ llvm-toolchain-focal-11 main' | tee /etc/apt/sources.list.d/llvm-toolchain-focal-11.list &amp;&amp; \
  wget -qO - https://apt.llvm.org/llvm-snapshot.gpg.key | apt-key add - &amp;&amp; \
  echo 'deb [arch=amd64] https://packages.microsoft.com/ubuntu/20.04/prod focal main' | tee /etc/apt/sources.list.d/msprod.list &amp;&amp; \
  wget -qO - https://packages.microsoft.com/keys/microsoft.asc | apt-key add - &amp;&amp; \
  apt update &amp;&amp; \
  apt -y install clang-11 libssl-dev gdb libsgx-enclave-common libsgx-quote-ex libprotobuf17 libsgx-dcap-ql libsgx-dcap-ql-dev az-dcap-client open-enclave &amp;&amp; \
  apt -y install dkms &amp;&amp; \
  source /opt/openenclave/share/openenclave/openenclaverc &amp;&amp; \
  mkdir -p /src/src/openenclave/build &amp;&amp; cd /src/src/openenclave/build &amp;&amp; \
  cmake .. &amp;&amp; make &amp;&amp; make run &amp;&amp; \
  exec bash"
</code></pre>
<p>Once the build is complete, see the OpenEnclave Host Command Line Tutorial below for instructions on running the OpenEnclave Libdogecoin Key Manager Enclave.</p>
<h2 id="host-command-line-tutorials"><a class="header" href="#host-command-line-tutorials">Host Command Line Tutorials</a></h2>
<p>In this section, we provide a step-by-step tutorial on using the host command line interface to interact with the key management enclaves in both environments. This tutorial will cover the basic operations including generating mnemonic seedphrases, generating public keys, generating addresses, signing messages, and signing transactions.</p>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<p>Before proceeding, ensure you have successfully built and set up the OP-TEE and OpenEnclave environments as described in the previous sections.</p>
<h3 id="op-tee-host-command-line-tutorial"><a class="header" href="#op-tee-host-command-line-tutorial">OP-TEE Host Command Line Tutorial</a></h3>
<h4 id="generating-a-mnemonic-seedphrase"><a class="header" href="#generating-a-mnemonic-seedphrase">Generating a Mnemonic Seedphrase</a></h4>
<p>Generate a mnemonic seedphrase for backup and recovery purposes. This is the first step in creating a new wallet. It will only be displayed once, so make sure to back it up.</p>
<p>This command will generate a mnemonic seedphrase and display it on the screen. Either a shared secret for TOTP or a password must be provided. All other flags are optional, and the user will be prompted for input if not provided.</p>
<p>Enter the shared secret for TOTP when prompted if enabled. The shared secret must be 40 hex characters (<em>e.g., <code>f38243e0e3e97a5c8aa5cc481a815add6c119648</code></em>).  If no shared secret is provided, a random one will be generated. The shared secret will be set on the YubiKey (if present) by the host application, and the mnemonic will be generated and displayed. If OTP Slot 1 is already programmed, the host application will prompt you to overwrite it. Ensure that your YubiKey slot configuration is not overwritten unless intended.</p>
<pre><code class="language-sh">optee_libdogecoin -c generate_mnemonic -n &lt;mnemonic_input&gt; -s &lt;shared_secret&gt; -e &lt;entropy_size&gt; -p &lt;password&gt; -f &lt;flags&gt; -z
</code></pre>
<p>The <code>-n</code> flag is used to provide the mnemonic input for recovery purposes if needed. Replace <code>&lt;mnemonic_input&gt;</code> with the mnemonic seedphrase you want to use for recovery. If no mnemonic input is provided, the enclave will generate a random mnemonic seedphrase.</p>
<p>The <code>-s</code> flag is used to provide the shared secret for TOTP authentication from command line instead of prompting the user. Replace <code>&lt;shared_secret&gt;</code> with the shared secret you want to use for TOTP authentication.</p>
<p>The <code>-e</code> flag is used to provide the entropy size for the mnemonic seedphrase. Replace <code>&lt;entropy_size&gt;</code> with the desired entropy size in bits. If no entropy size is provided, the default value of <code>"256"</code> bits (24 words) will be used.</p>
<p>The <code>-p</code> flag is used to provide the password for the mnemonic seedphrase. Replace <code>&lt;password&gt;</code> with the password you want to use for the mnemonic seedphrase.</p>
<p>The <code>-f</code> flag is used to provide additional flags for the mnemonic seedphrase. Replace <code>&lt;flags&gt;</code> with the desired flags for the mnemonic seedphrase. The <code>"delegate"</code> flag is used to delegate account keys to a third party.</p>
<p>The <code>-z</code> flag is used to enable YubiKey authentication. If the YubiKey is present, the shared secret will be set on the YubiKey.</p>
<h4 id="generating-an-extended-public-key"><a class="header" href="#generating-an-extended-public-key">Generating an Extended Public Key</a></h4>
<p>Generate an extended public key using the account and change level. The change level can be set to 0 for external addresses and 1 for internal addresses. The account number is the BIP-44 account. The public key will be derived from the seedphrase stored within the enclave.</p>
<p>The <code>-o</code> flag is used to provide the account number for the extended public key. Replace <code>&lt;account_number&gt;</code> with the desired account number.</p>
<p>The <code>-l</code> flag is used to provide the change level for the extended public key. Replace <code>&lt;change_level&gt;</code> with the desired change level.</p>
<p>The <code>-h</code> flag is used to provide a custom path for the extended public key. Replace <code>&lt;custom_path&gt;</code> with the desired path for the extended public key.</p>
<p>The <code>-a</code> flag is used to provide the auth token if a Yubikey is not present. Use a tool like <code>oathtool</code> to generate TOTP (*e.g., <code>oathtool --totp "f38243e0e3e97a5c8aa5cc481a815add6c119648"</code>).</p>
<p>The <code>-p</code> flag is used to provide the password for the mnemonic seedphrase.</p>
<p>The <code>-z</code> flag is used to enable YubiKey authentication. If the YubiKey is present, the TOTP code will be retrieved from the YubiKey and used as the authentication token.</p>
<pre><code class="language-sh">optee_libdogecoin -c generate_extended_public_key -o &lt;account_number&gt; -l &lt;change_level&gt; -h &lt;custom_path&gt; -a &lt;auth_token&gt; or -p &lt;password&gt; -z
</code></pre>
<h4 id="generating-an-address"><a class="header" href="#generating-an-address">Generating an Address</a></h4>
<p>Generate a Dogecoin address using the account, address index, and change level.</p>
<pre><code class="language-sh">optee_libdogecoin -c generate_address -o &lt;account_number&gt; -l &lt;change_level&gt; -i &lt;address_index&gt; -h &lt;custom_path&gt; -a &lt;auth_token&gt; or -p &lt;password&gt; -z
</code></pre>
<p>Replace <code>&lt;account_number&gt;</code>, <code>&lt;address_index&gt;</code>, and <code>&lt;change_level&gt;</code> with appropriate values. The change level can be set to 0 for external addresses and 1 for internal addresses. The account number is the BIP-44 account. The address index is the index of the address within the account. The address will be derived from the seedphrase stored within the enclave.</p>
<h4 id="signing-a-message"><a class="header" href="#signing-a-message">Signing a Message</a></h4>
<p>Sign a message using the private key stored within the enclave. The message will be signed using the private key derived from the seedphrase stored within the enclave. If no message is provided, an example message will be signed for demonstration purposes.</p>
<pre><code class="language-sh">optee_libdogecoin -c sign_message -o &lt;account_number&gt; -l &lt;change_level&gt; -i &lt;address_index&gt; -m &lt;message&gt; -h &lt;custom_path&gt; -a &lt;auth_token&gt; or -p &lt;password&gt; -z
</code></pre>
<p>Replace <code>&lt;message&gt;</code> with the message you want to sign.</p>
<h4 id="signing-a-transaction"><a class="header" href="#signing-a-transaction">Signing a Transaction</a></h4>
<p>Sign a raw transaction using the private key stored within the enclave. The transaction will be signed using the private key derived from the seedphrase stored within the enclave. A raw transaction is a hexadecimal string representing the transaction data. Currently, if no transaction data is provided, an example transaction will be signed for demonstration purposes.</p>
<pre><code class="language-sh">optee_libdogecoin -c sign_transaction -o &lt;account_number&gt; -l &lt;change_level&gt; -i &lt;address_index&gt; -t &lt;raw_transaction&gt; -h &lt;custom_path&gt; -a &lt;auth_token&gt; or -p &lt;password&gt; -z
</code></pre>
<p>Replace <code>&lt;raw_transaction&gt;</code> with the raw transaction data.</p>
<h4 id="delegate-key"><a class="header" href="#delegate-key">Delegate Key</a></h4>
<p>Delegate account keys to a third party. This operation allows a third party to manage the keys for a specific account. The third party will be able to export the account keys on behalf of the user using the delegate password.</p>
<pre><code class="language-sh">optee_libdogecoin -c delegate_key -o &lt;account_number&gt; -d &lt;delegate_password&gt; -h &lt;custom_path&gt; -a &lt;auth_token&gt; or -p &lt;password&gt; -z
</code></pre>
<p>Replace <code>&lt;delegate_password&gt;</code> with the password for the delegate account.</p>
<h4 id="export-delegate-key"><a class="header" href="#export-delegate-key">Export Delegate Key</a></h4>
<p>Export the delegated account keys using the delegate password. This operation allows the third party to export the account keys on behalf of the user.</p>
<pre><code class="language-sh">optee_libdogecoin -c export_delegate_key -o &lt;account_number&gt; -d &lt;delegate_password&gt;
</code></pre>
<p>Replace <code>&lt;delegate_password&gt;</code> with the password for the delegate account.</p>
<h3 id="openenclave-host-command-line-tutorial"><a class="header" href="#openenclave-host-command-line-tutorial">OpenEnclave Host Command Line Tutorial</a></h3>
<p>Note: In OpenEnclave, <code>--simulate</code> is used to run the enclave in simulation mode. This is useful for testing without SGX hardware, but it is not secure. For production use, remove <code>--simulate</code> to run on real SGX hardware.</p>
<h4 id="generating-a-mnemonic-seedphrase-1"><a class="header" href="#generating-a-mnemonic-seedphrase-1">Generating a Mnemonic Seedphrase</a></h4>
<p>Generate a mnemonic seedphrase for backup and recovery purposes. This is the first step in creating a new wallet. It will only be displayed once, so make sure to back it up.</p>
<p>This command will generate a mnemonic seedphrase and display it on the screen. Either a shared secret for TOTP or a password must be provided. All other flags are optional, and the user will be prompted for input if not provided.</p>
<p>Enter the shared secret for TOTP when prompted if enabled. The shared secret must be 40 hex characters (<em>e.g., <code>f38243e0e3e97a5c8aa5cc481a815add6c119648</code></em>).  If no shared secret is provided, a random one will be generated. The shared secret will be set on the YubiKey (if present) by the host application, and the mnemonic will be generated and displayed. If OTP Slot 1 is already programmed, the host application will prompt you to overwrite it.</p>
<pre><code class="language-sh">/doge/libdogecoin/src/openenclave/build/host/host /doge/libdogecoin/src/openenclave/build/enclave/enclave.signed --simulate -c generate_mnemonic -n &lt;mnemonic_input&gt; -s &lt;shared_secret&gt; -e &lt;entropy_size&gt; -p &lt;password&gt; -z
</code></pre>
<p>The <code>-n</code> flag is used to provide the mnemonic input for recovery purposes if needed. Replace <code>&lt;mnemonic_input&gt;</code> with the mnemonic seedphrase you want to use for recovery. If no mnemonic input is provided, the enclave will generate a random mnemonic seedphrase.</p>
<p>The <code>-s</code> flag is used to provide the shared secret for TOTP authentication from command line instead of prompting the user. Replace <code>&lt;shared_secret&gt;</code> with the shared secret you want to use for TOTP authentication.</p>
<p>The <code>-e</code> flag is used to provide the entropy size for the mnemonic seedphrase. Replace <code>&lt;entropy_size&gt;</code> with the desired entropy size in bits. If no entropy size is provided, the default value of <code>"256"</code> bits (24 words) will be used.</p>
<p>The <code>-p</code> flag is used to provide the password for the mnemonic seedphrase. Replace <code>&lt;password&gt;</code> with the password you want to use for the mnemonic seedphrase.</p>
<p>The <code>-z</code> flag is used to enable YubiKey authentication. If the YubiKey is present, the shared secret will be set on the YubiKey.</p>
<h4 id="generating-an-extended-public-key-1"><a class="header" href="#generating-an-extended-public-key-1">Generating an Extended Public Key</a></h4>
<p>Generate an extended public key using the account and change level. The change level can be set to 0 for external addresses and 1 for internal addresses. The account number is the BIP-44 account.</p>
<p>The TOTP code will be retrieved from the YubiKey (if present) and used as the authentication token for this operation.</p>
<pre><code class="language-sh">/doge/libdogecoin/src/openenclave/build/host/host /doge/libdogecoin/src/openenclave/build/enclave/enclave.signed --simulate -c generate_extended_public_key -o &lt;account_number&gt; -l &lt;change_level&gt; -h &lt;custom_path&gt; -a &lt;auth_token&gt; or -p &lt;password&gt; -z
</code></pre>
<p>The <code>-o</code> flag is used to provide the account number for the extended public key. Replace <code>&lt;account_number&gt;</code> with the desired account number.</p>
<p>The <code>-l</code> flag is used to provide the change level for the extended public key. Replace <code>&lt;change_level&gt;</code> with the desired change level.</p>
<p>The <code>-h</code> flag is used to provide a custom path for the extended public key. Replace <code>&lt;custom_path&gt;</code> with the desired path for the extended public key.</p>
<p>The <code>-a</code> flag is used to provide the auth token if a Yubikey is not present. Use a tool like <code>oathtool</code> to generate TOTP (*e.g., <code>oathtool --totp "f38243e0e3e97a5c8aa5cc481a815add6c119648"</code>).</p>
<p>The <code>-p</code> flag is used to provide the password for the mnemonic seedphrase.</p>
<p>The <code>-z</code> flag is used to enable YubiKey authentication. If the YubiKey is present, the TOTP code will be retrieved from the YubiKey and used as the authentication token.</p>
<h4 id="generating-an-address-1"><a class="header" href="#generating-an-address-1">Generating an Address</a></h4>
<p>Generate a Dogecoin address using the account, address index, and change level.</p>
<pre><code class="language-sh">/doge/libdogecoin/src/openenclave/build/host/host /doge/libdogecoin/src/openenclave/build/enclave/enclave.signed --simulate -c generate_address -o &lt;account_number&gt; -l &lt;change_level&gt; -i &lt;address_index&gt; -h &lt;custom_path&gt; -a &lt;auth_token&gt; or -p &lt;password&gt; -z
</code></pre>
<p>Replace <code>&lt;account_number&gt;</code>, <code>&lt;address_index&gt;</code>, and <code>&lt;change_level&gt;</code> with appropriate values.</p>
<h4 id="signing-a-message-1"><a class="header" href="#signing-a-message-1">Signing a Message</a></h4>
<p>Sign a message using the private key stored within the enclave. If no message is provided, an example message will be signed for demonstration purposes.</p>
<pre><code class="language-sh">/doge/libdogecoin/src/openenclave/build/host/host /doge/libdogecoin/src/openenclave/build/enclave/enclave.signed --simulate -c sign_message -o &lt;account_number&gt; -l &lt;change_level&gt; -i &lt;address_index&gt; -m "This is just a test message" -h &lt;custom_path&gt; -a &lt;auth_token&gt; or -p &lt;password&gt; -z
</code></pre>
<p>Replace <code>"This is just a test message"</code> with the message you want to sign.</p>
<h4 id="signing-a-transaction-1"><a class="header" href="#signing-a-transaction-1">Signing a Transaction</a></h4>
<p>Sign a raw transaction using the private key stored within the enclave. The transaction will be signed using the private key derived from the seedphrase stored within the enclave. A raw transaction is a hexadecimal string representing the transaction data. Currently, if no transaction data is provided, an example transaction will be signed for demonstration purposes.</p>
<pre><code class="language-sh">/doge/libdogecoin/src/openenclave/build/host/host /doge/libdogecoin/src/openenclave/build/enclave/enclave.signed --simulate -c sign_transaction -o &lt;account_number&gt; -l &lt;change_level&gt; -i &lt;address_index&gt; -t &lt;raw_transaction&gt; -h &lt;custom_path&gt; -a &lt;auth_token&gt; or -p &lt;password&gt; -z
</code></pre>
<p>Replace <code>&lt;raw_transaction&gt;</code> with the raw transaction data.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this document, we explored the integration of libdogecoin with secure enclaves in Trusted Execution Environments (TEEs). We discussed the benefits of using Intel SGX and ARM TrustZone to secure key management operations, including mnemonic seedphrase generation, public key generation, address generation, message signing, and transaction signing. We provided a step-by-step tutorial on using the host command line interface to interact with the key management enclaves in both OP-TEE and OpenEnclave environments. We also outlined critical vulnerabilities in TEEs and provided recommendations for mitigating these risks. We hope this document serves as a valuable resource for developers looking to enhance the security of Dogecoin transactions using secure enclaves.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libdogecoin-spv-rest-api-documentation"><a class="header" href="#libdogecoin-spv-rest-api-documentation">Libdogecoin SPV REST API Documentation</a></h1>
<h2 id="table-of-contents-3"><a class="header" href="#table-of-contents-3">Table of Contents</a></h2>
<ul>
<li><a href="rest.html#dogecoin-spv-rest-api-documentation">Libdogecoin SPV REST API Documentation</a>
<ul>
<li><a href="rest.html#table-of-contents">Table of Contents</a></li>
<li><a href="rest.html#abstract">Abstract</a></li>
<li><a href="rest.html#endpoints">Endpoints</a>
<ul>
<li><a href="rest.html#get-getbalance">GET /getBalance</a></li>
<li><a href="rest.html#get-getaddresses">GET /getAddresses</a></li>
<li><a href="rest.html#get-gettransactions">GET /getTransactions</a></li>
<li><a href="rest.html#get-getutxos">GET /getUTXOs</a></li>
<li><a href="rest.html#get-getwallet">GET /getWallet</a></li>
<li><a href="rest.html#get-getheaders">GET /getHeaders</a></li>
<li><a href="rest.html#get-getchaintip">GET /getChaintip</a></li>
<li><a href="rest.html#get-gettimestamp">GET /getTimestamp</a></li>
<li><a href="rest.html#get-getlastblockinfo">GET /getLastBlockInfo</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="abstract-1"><a class="header" href="#abstract-1">Abstract</a></h2>
<p>This document describes the REST API endpoints exposed by the Libdogecoin SPV node. The API provides access to wallet information, such as balance, addresses, transactions, UTXOs, as well as wallet and blockchain data like wallet files, headers, and the chain tip. The API is designed to facilitate interaction with the Libdogecoin SPV node programmatically.</p>
<h2 id="endpoints"><a class="header" href="#endpoints">Endpoints</a></h2>
<h3 id="get-getbalance"><a class="header" href="#get-getbalance">GET <strong>/getBalance</strong></a></h3>
<p>Retrieves the total balance of the wallet.</p>
<h4 id="request"><a class="header" href="#request"><strong>Request</strong></a></h4>
<ul>
<li><strong>Method:</strong> <code>GET</code></li>
<li><strong>URL:</strong> <code>/getBalance</code></li>
</ul>
<h4 id="response"><a class="header" href="#response"><strong>Response</strong></a></h4>
<ul>
<li>
<p><strong>Content-Type:</strong> <code>text/plain</code></p>
</li>
<li>
<p><strong>Body:</strong></p>
<pre><code>Wallet balance: &lt;balance&gt;
</code></pre>
<p>Where <code>&lt;balance&gt;</code> is the total balance of the wallet in Dogecoin.</p>
</li>
</ul>
<h4 id="example"><a class="header" href="#example"><strong>Example</strong></a></h4>
<pre><code class="language-bash">curl http://localhost:&lt;port&gt;/getBalance
</code></pre>
<h4 id="sample-response"><a class="header" href="#sample-response"><strong>Sample Response</strong></a></h4>
<pre><code>Wallet balance: 123.45678900
</code></pre>
<hr />
<h3 id="get-getaddresses"><a class="header" href="#get-getaddresses">GET <strong>/getAddresses</strong></a></h3>
<p>Retrieves all addresses associated with the wallet.</p>
<h4 id="request-1"><a class="header" href="#request-1"><strong>Request</strong></a></h4>
<ul>
<li><strong>Method:</strong> <code>GET</code></li>
<li><strong>URL:</strong> <code>/getAddresses</code></li>
</ul>
<h4 id="response-1"><a class="header" href="#response-1"><strong>Response</strong></a></h4>
<ul>
<li>
<p><strong>Content-Type:</strong> <code>text/plain</code></p>
</li>
<li>
<p><strong>Body:</strong></p>
<pre><code>address: &lt;address1&gt;
address: &lt;address2&gt;
...
</code></pre>
<p>Each line contains an address associated with the wallet.</p>
</li>
</ul>
<h4 id="example-1"><a class="header" href="#example-1"><strong>Example</strong></a></h4>
<pre><code class="language-bash">curl http://localhost:&lt;port&gt;/getAddresses
</code></pre>
<h4 id="sample-response-1"><a class="header" href="#sample-response-1"><strong>Sample Response</strong></a></h4>
<pre><code>address: DH5yaieqoZN36fDVciNyRueRGvGLR3mr7L
address: DQe1QeG4FxhEgvfuvGfC7oL5G2G87huuxU
</code></pre>
<hr />
<h3 id="get-gettransactions"><a class="header" href="#get-gettransactions">GET <strong>/getTransactions</strong></a></h3>
<p>Retrieves all spent (non-spendable) transactions associated with the wallet.</p>
<h4 id="request-2"><a class="header" href="#request-2"><strong>Request</strong></a></h4>
<ul>
<li><strong>Method:</strong> <code>GET</code></li>
<li><strong>URL:</strong> <code>/getTransactions</code></li>
</ul>
<h4 id="response-2"><a class="header" href="#response-2"><strong>Response</strong></a></h4>
<ul>
<li>
<p><strong>Content-Type:</strong> <code>text/plain</code></p>
</li>
<li>
<p><strong>Body:</strong></p>
<pre><code>----------------------
txid:           &lt;txid&gt;
vout:           &lt;vout&gt;
address:        &lt;address&gt;
script_pubkey:  &lt;script_pubkey&gt;
amount:         &lt;amount&gt;
confirmations:  &lt;confirmations&gt;
spendable:      &lt;spendable&gt;
solvable:       &lt;solvable&gt;
...
Spent Balance: &lt;total_spent_balance&gt;
</code></pre>
<p>Information about each spent transaction (UTXO) and the total spent balance.</p>
</li>
</ul>
<h4 id="example-2"><a class="header" href="#example-2"><strong>Example</strong></a></h4>
<pre><code class="language-bash">curl http://localhost:&lt;port&gt;/getTransactions
</code></pre>
<h4 id="sample-response-2"><a class="header" href="#sample-response-2"><strong>Sample Response</strong></a></h4>
<pre><code>----------------------
txid:           e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
vout:           0
address:        DH5yaieqoZN36fDVciNyRueRGvGLR3mr7L
script_pubkey:  76a9144621d6a7f3b4ebbaee4e2d8c10eafbf1ccbc9c0a88ac
amount:         50.00000000
confirmations:  100
spendable:      0
solvable:       1
Spent Balance: 50.00000000
</code></pre>
<hr />
<h3 id="get-getutxos"><a class="header" href="#get-getutxos">GET <strong>/getUTXOs</strong></a></h3>
<p>Retrieves all unspent transaction outputs (UTXOs) associated with the wallet.</p>
<h4 id="request-3"><a class="header" href="#request-3"><strong>Request</strong></a></h4>
<ul>
<li><strong>Method:</strong> <code>GET</code></li>
<li><strong>URL:</strong> <code>/getUTXOs</code></li>
</ul>
<h4 id="response-3"><a class="header" href="#response-3"><strong>Response</strong></a></h4>
<ul>
<li>
<p><strong>Content-Type:</strong> <code>text/plain</code></p>
</li>
<li>
<p><strong>Body:</strong></p>
<pre><code>----------------------
Unspent UTXO:
txid:           &lt;txid&gt;
vout:           &lt;vout&gt;
address:        &lt;address&gt;
script_pubkey:  &lt;script_pubkey&gt;
amount:         &lt;amount&gt;
confirmations:  &lt;confirmations&gt;
spendable:      &lt;spendable&gt;
solvable:       &lt;solvable&gt;
...
Total Unspent: &lt;total_unspent_balance&gt;
</code></pre>
<p>Information about each unspent transaction output and the total unspent balance.</p>
</li>
</ul>
<h4 id="example-3"><a class="header" href="#example-3"><strong>Example</strong></a></h4>
<pre><code class="language-bash">curl http://localhost:&lt;port&gt;/getUTXOs
</code></pre>
<h4 id="sample-response-3"><a class="header" href="#sample-response-3"><strong>Sample Response</strong></a></h4>
<pre><code>----------------------
Unspent UTXO:
txid:           b1fea5241c4a1d7d1e6c6d619fbf3bb8b1ec3f1f1d2f4c5b6a7c8d9e0f1a2b3c
vout:           1
address:        DQe1QeG4FxhEgvfuvGfC7oL5G2G87huuxU
script_pubkey:  76a9145d6a7f3b4ebbaee4e2d8c10eafbf1ccbc9c0a88ac
amount:         75.00000000
confirmations:  100
spendable:      1
solvable:       1
Total Unspent: 75.00000000
</code></pre>
<hr />
<h3 id="get-getwallet"><a class="header" href="#get-getwallet">GET <strong>/getWallet</strong></a></h3>
<p>Downloads the wallet file associated with the node.</p>
<h4 id="request-4"><a class="header" href="#request-4"><strong>Request</strong></a></h4>
<ul>
<li><strong>Method:</strong> <code>GET</code></li>
<li><strong>URL:</strong> <code>/getWallet</code></li>
</ul>
<h4 id="response-4"><a class="header" href="#response-4"><strong>Response</strong></a></h4>
<ul>
<li>
<p><strong>Content-Type:</strong> <code>application/octet-stream</code></p>
</li>
<li>
<p><strong>Body:</strong></p>
<p>Binary data of the wallet file.</p>
</li>
</ul>
<h4 id="example-4"><a class="header" href="#example-4"><strong>Example</strong></a></h4>
<pre><code class="language-bash">curl -O http://localhost:&lt;port&gt;/getWallet
</code></pre>
<h4 id="notes"><a class="header" href="#notes"><strong>Notes</strong></a></h4>
<ul>
<li>The response is a binary file.</li>
<li>Ensure that it's secure as it contains sensitive information.</li>
</ul>
<hr />
<h3 id="get-getheaders"><a class="header" href="#get-getheaders">GET <strong>/getHeaders</strong></a></h3>
<p>Downloads the headers file used by the SPV node.</p>
<h4 id="request-5"><a class="header" href="#request-5"><strong>Request</strong></a></h4>
<ul>
<li><strong>Method:</strong> <code>GET</code></li>
<li><strong>URL:</strong> <code>/getHeaders</code></li>
</ul>
<h4 id="response-5"><a class="header" href="#response-5"><strong>Response</strong></a></h4>
<ul>
<li>
<p><strong>Content-Type:</strong> <code>application/octet-stream</code></p>
</li>
<li>
<p><strong>Body:</strong></p>
<p>Binary data of the headers file.</p>
</li>
</ul>
<h4 id="example-5"><a class="header" href="#example-5"><strong>Example</strong></a></h4>
<pre><code class="language-bash">curl -O http://localhost:&lt;port&gt;/getHeaders
</code></pre>
<h4 id="notes-1"><a class="header" href="#notes-1"><strong>Notes</strong></a></h4>
<ul>
<li>The response is a binary file containing blockchain headers.</li>
<li>Useful for debugging or analysis purposes.</li>
</ul>
<hr />
<h3 id="get-getchaintip"><a class="header" href="#get-getchaintip">GET <strong>/getChaintip</strong></a></h3>
<p>Retrieves the current chain tip (the latest block height known to the node).</p>
<h4 id="request-6"><a class="header" href="#request-6"><strong>Request</strong></a></h4>
<ul>
<li><strong>Method:</strong> <code>GET</code></li>
<li><strong>URL:</strong> <code>/getChaintip</code></li>
</ul>
<h4 id="response-6"><a class="header" href="#response-6"><strong>Response</strong></a></h4>
<ul>
<li>
<p><strong>Content-Type:</strong> <code>text/plain</code></p>
</li>
<li>
<p><strong>Body:</strong></p>
<pre><code>Chain tip: &lt;block_height&gt;
</code></pre>
<p>Where <code>&lt;block_height&gt;</code> is the height of the latest block known to the SPV node.</p>
</li>
</ul>
<h4 id="example-6"><a class="header" href="#example-6"><strong>Example</strong></a></h4>
<pre><code class="language-bash">curl http://localhost:&lt;port&gt;/getChaintip
</code></pre>
<h4 id="sample-response-4"><a class="header" href="#sample-response-4"><strong>Sample Response</strong></a></h4>
<pre><code>Chain tip: 3500000
</code></pre>
<hr />
<h3 id="get-gettimestamp"><a class="header" href="#get-gettimestamp">GET <strong>/getTimestamp</strong></a></h3>
<p>Retrieves the current timestamp of the SPV node.</p>
<h4 id="request-7"><a class="header" href="#request-7"><strong>Request</strong></a></h4>
<ul>
<li><strong>Method:</strong> <code>GET</code></li>
<li><strong>URL:</strong> <code>/getTimestamp</code></li>
</ul>
<h4 id="response-7"><a class="header" href="#response-7"><strong>Response</strong></a></h4>
<ul>
<li>
<p><strong>Content-Type:</strong> <code>text/plain</code></p>
</li>
<li>
<p><strong>Body:</strong></p>
<pre><code>Timestamp: &lt;timestamp&gt;
</code></pre>
<p>Where <code>&lt;timestamp&gt;</code> is the current date and local time of the SPV node.</p>
</li>
</ul>
<h4 id="example-7"><a class="header" href="#example-7"><strong>Example</strong></a></h4>
<pre><code class="language-bash">curl http://localhost:&lt;port&gt;/getTimestamp
</code></pre>
<h4 id="sample-response-5"><a class="header" href="#sample-response-5"><strong>Sample Response</strong></a></h4>
<pre><code>2024-10-26 15:30:00
</code></pre>
<hr />
<h3 id="get-getlastblockinfo"><a class="header" href="#get-getlastblockinfo">GET <strong>/getLastBlockInfo</strong></a></h3>
<p>Retrieves information about the last block processed by the SPV node.</p>
<h4 id="request-8"><a class="header" href="#request-8"><strong>Request</strong></a></h4>
<ul>
<li>
<p><strong>Method:</strong> <code>GET</code></p>
</li>
<li>
<p><strong>URL:</strong> <code>/getLastBlockInfo</code></p>
</li>
</ul>
<h4 id="response-8"><a class="header" href="#response-8"><strong>Response</strong></a></h4>
<ul>
<li>
<p><strong>Content-Type:</strong> <code>text/plain</code></p>
</li>
<li>
<p><strong>Body:</strong></p>
<pre><code>Block size: &lt;last_block_size&gt;
Tx count: &lt;last_block_tx_count&gt;
Total tx size: &lt;last_block_total_tx_size&gt;
</code></pre>
<p>Where:</p>
<ul>
<li><code>&lt;last_block_size&gt;</code> is the size of the last block in bytes.</li>
<li><code>&lt;last_block_tx_count&gt;</code> is the number of transactions in the last block.</li>
<li><code>&lt;last_block_total_tx_size&gt;</code> is the total size of transactions in the last block.</li>
</ul>
</li>
</ul>
<h4 id="example-8"><a class="header" href="#example-8"><strong>Example</strong></a></h4>
<pre><code class="language-bash">curl http://localhost:&lt;port&gt;/getLastBlockInfo
</code></pre>
<h4 id="sample-response-6"><a class="header" href="#sample-response-6"><strong>Sample Response</strong></a></h4>
<pre><code>Block size: 4130
Tx count: 11
Total tx size: 3355
</code></pre>
<hr />
<h2 id="additional-information"><a class="header" href="#additional-information">Additional Information</a></h2>
<ul>
<li><strong>Server Address:</strong> Replace <code>&lt;port&gt;</code> in the examples with the port number where your Libdogecoin SPV node is running.</li>
<li><strong>Content Types:</strong>
<ul>
<li>Endpoints returning plain text data use <code>Content-Type: text/plain</code>.</li>
<li>Endpoints returning binary data use <code>Content-Type: application/octet-stream</code>.</li>
</ul>
</li>
<li><strong>Security Considerations:</strong>
<ul>
<li>Sensitive endpoints like <code>/getWallet</code> expose critical data.</li>
<li>Always safeguard your wallet file to prevent unauthorized access to your funds.</li>
</ul>
</li>
</ul>
<h2 id="usage-notes"><a class="header" href="#usage-notes">Usage Notes</a></h2>
<ul>
<li>
<p><strong>cURL:</strong> The examples use <code>curl</code> for simplicity. You can use any HTTP node to interact with the API.</p>
</li>
<li>
<p><strong>Error Handling:</strong> If an endpoint encounters an error, it will respond with an appropriate HTTP status code and message.</p>
<ul>
<li>
<p>For example, if the wallet file is not found:</p>
<pre><code>HTTP/1.1 404 Not Found
Content-Type: text/plain

Wallet file not found
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Concurrency:</strong> The SPV node should handle multiple concurrent requests gracefully. However, ensure that shared resources like the wallet and UTXO set are managed in a thread-safe manner.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libdogecoin-signing-api"><a class="header" href="#libdogecoin-signing-api">Libdogecoin Signing API</a></h1>
<h2 id="table-of-contents-4"><a class="header" href="#table-of-contents-4">Table of Contents</a></h2>
<ul>
<li><a href="signing.html#libdogecoin-signing-api">Libdogecoin Signing API</a>
<ul>
<li><a href="signing.html#table-of-contents">Table of Contents</a></li>
<li><a href="signing.html#abstract">Abstract</a></li>
<li><a href="signing.html#basic-signing-api">Basic Signing API</a>
<ul>
<li><a href="signing.html#sign_message"><strong>sign_message:</strong></a></li>
<li><a href="signing.html#verify_message"><strong>verify_message:</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="abstract-2"><a class="header" href="#abstract-2">Abstract</a></h2>
<p>This document describes the process of message signing within libdogecoin. It aims to meet the standards defined in <a href="https://github.com/bitcoin/bips/blob/master/bip-0137.mediawiki">BIP-137</a> although the implementation is only applicable to P2PKH addresses.</p>
<h2 id="basic-signing-api"><a class="header" href="#basic-signing-api">Basic Signing API</a></h2>
<hr />
<h3 id="sign_message"><a class="header" href="#sign_message"><strong>sign_message:</strong></a></h3>
<pre><code class="language-c">char* sign_message(char* privkey, char* msg) {
    if (!privkey || !msg) return false;

    uint256_t message_bytes;
    hash_message(msg, message_bytes);

    size_t compact_signature_length = 65;
    unsigned char* compact_signature = dogecoin_uchar_vla(compact_signature_length);

    dogecoin_key key;
    dogecoin_pubkey pubkey;
    if (!init_keypair(privkey, &amp;key, &amp;pubkey)) return false;

    int recid = -1;

    if (!dogecoin_key_sign_hash_compact_recoverable_fcomp(&amp;key, message_bytes, compact_signature, &amp;compact_signature_length, &amp;recid)) return false;
    if (!dogecoin_key_recover_pubkey((const unsigned char*)compact_signature, message_bytes, recid, &amp;pubkey)) return false;

    char p2pkh_address[P2PKHLEN];
    if (!dogecoin_pubkey_getaddr_p2pkh(&amp;pubkey, &amp;dogecoin_chainparams_main, p2pkh_address)) return false;

    unsigned char* base64_encoded_output = dogecoin_uchar_vla(1+(sizeof(char)*base64_encoded_size(compact_signature_length)));
    base64_encode((unsigned char*)compact_signature, compact_signature_length, base64_encoded_output);

    dogecoin_free(compact_signature);
    dogecoin_privkey_cleanse(&amp;key);
    dogecoin_pubkey_cleanse(&amp;pubkey);

    return (char*)base64_encoded_output;
}
</code></pre>
<p>This function signs a message with a private key.</p>
<p><em>C usage:</em></p>
<pre><code class="language-c">char* sig = sign_message("QUtnMFjt3JFk1NfeMe6Dj5u4p25DHZA54FsvEFAiQxcNP4bZkPu2", "This is just a test message");
</code></pre>
<hr />
<h3 id="verify_message"><a class="header" href="#verify_message"><strong>verify_message:</strong></a></h3>
<pre><code class="language-c">int verify_message(char* sig, char* msg, char* address) {
    if (!(sig || msg || address)) return false;

    uint256_t message_bytes;
    hash_message(msg, message_bytes);

    size_t encoded_length = strlen((const char*)sig);
    unsigned char* decoded_signature = dogecoin_uchar_vla(base64_decoded_size(encoded_length+1)+1);
    base64_decode((unsigned char*)sig, encoded_length, decoded_signature);

    dogecoin_pubkey pub_key;
    dogecoin_pubkey_init(&amp;pub_key);
    pub_key.compressed = false;

    int header = decoded_signature[0] &amp; 0xFF;

    if (header &lt; 27 || header &gt; 42) return false;

    if (header &gt;= 31) {
        pub_key.compressed = true;
        header -= 4;
    }

    int recid = header - 27;
    if (!dogecoin_key_recover_pubkey((const unsigned char*)decoded_signature, message_bytes, recid, &amp;pub_key)) return false;
    if (!dogecoin_pubkey_verify_sigcmp(&amp;pub_key, message_bytes, decoded_signature)) return false;

    char p2pkh_address[P2PKHLEN];
    const dogecoin_chainparams* chain = chain_from_b58_prefix(address);
    if (!dogecoin_pubkey_getaddr_p2pkh(&amp;pub_key, chain, p2pkh_address)) return false;

    dogecoin_free(decoded_signature);
    dogecoin_pubkey_cleanse(&amp;pub_key);
    return strcmp(p2pkh_address, address)==0;
}
</code></pre>
<p>This function verifies a signed message using a P2PKH address.</p>
<p><em>C usage:</em></p>
<pre><code class="language-c">char* address = "DA8aeVkgQWwo78y3VCXtLqoWe8uWRoFuc1";
int ret = verify_message(sig, msg, address);
if (!ret) {
  return false;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-libdogecoin-tools"><a class="header" href="#using-libdogecoin-tools">Using Libdogecoin Tools</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>If you are looking to just explore the functionality of Libdogecoin without building a complicated project yourself, look no further than the CLI tools provided in this repo. The first tool, <code>such</code>, is an interactive CLI application that allows you to perform all Essential address and transaction operations with prompts to guide you through the process. The second tool, <code>sendtx</code>, handles the process of broadcasting a transaction built using Libdogecoin to eventually push it onto the blockchain. The third tool, <code>spvnode</code>, run a Simple Payment Verification (SPV) node for the Dogecoin blockchain. It enables users to interact with the Dogecoin network, verify transactions and stay in sync with the blockchain.</p>
<p>This document goes over the usage of these tools along with examples of how to use them.</p>
<h2 id="the-such-tool"><a class="header" href="#the-such-tool">The <code>such</code> Tool</a></h2>
<p>As stated above, the <code>such</code> tool can be used to perform all Libdogecoin address and transaction functions, and even more. It can generate different types of public and private keys, derive and convert keys, and fully build and sign transactions.</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<p>The <code>such</code> tool can be used by simply running the command <code>./such</code> in the top level of the Libdogecoin directory, always followed by a <code>-c</code> flag that denotes the desired <code>such</code> command to run. The options for this command are below:</p>
<ul>
<li>generate_private_key</li>
<li>generate_public_key</li>
<li>p2pkh</li>
<li>bip32_extended_master_key</li>
<li>derive_child_keys</li>
<li>generate_mnemonic</li>
<li>list_encryption_keys_in_tpm</li>
<li>decrypt_master_key</li>
<li>decrypt_mnemonic</li>
<li>seed_to_master_key</li>
<li>mnemonic_to_key</li>
<li>mnemonic_to_addresses</li>
<li>print_keys</li>
<li>sign</li>
<li>comp2der</li>
<li>bip32maintotest</li>
<li>signmessage</li>
<li>verify_message</li>
<li>transaction</li>
</ul>
<p>So an example run of <code>such</code> could be something like this:</p>
<pre><code>./such -c generate_private_key
</code></pre>
<p>Most of these commands require a flag following them to denote things like existing keys, transaction hex strings, and more:</p>
<div class="table-wrapper"><table><thead><tr><th>Flag</th><th>Name</th><th>Required Arg?</th><th>Usage</th></tr></thead><tbody>
<tr><td>-p, --privkey</td><td>private_key</td><td>yes</td><td>generate_public_key -p &lt;private_key&gt;</td></tr>
<tr><td>-k, --pubkey</td><td>public_key</td><td>yes</td><td>p2pkh -k &lt;public_key&gt;</td></tr>
<tr><td>-m, --derived_path</td><td>derived_path</td><td>yes</td><td>derive_child_key -p &lt;extended_private_key&gt; -m &lt;derived_path&gt;</td></tr>
<tr><td>-e, --entropy</td><td>hex_entropy</td><td>yes</td><td>generate_mnemonic -e &lt;hex_entropy&gt;</td></tr>
<tr><td>-n, --mnemonic</td><td>seed_phrase</td><td>yes</td><td>mnemonic_to_key or mnemonic_to_addresses -n &lt;seed_phrase&gt;</td></tr>
<tr><td>-a, --pass_phrase</td><td>pass_phrase</td><td>no</td><td>mnemonic_to_key or mnemonic_to_addresses -n &lt;seed_phrase&gt; -a</td></tr>
<tr><td>-o, --account_int</td><td>account_int</td><td>yes</td><td>mnemonic_to_key or mnemonic_to_addresses -n &lt;seed_phrase&gt; -o &lt;account_int&gt;</td></tr>
<tr><td>-g, --change_level</td><td>change_level</td><td>yes</td><td>mnemonic_to_key or mnemonic_to_addresses -n &lt;seed_phrase&gt; -g &lt;change_level&gt;</td></tr>
<tr><td>-i, --address_index</td><td>address_index</td><td>yes</td><td>mnemonic_to_key or mnemonic_to_addresses -n &lt;seed_phrase&gt; -i &lt;address_index&gt;</td></tr>
<tr><td>-y, --encrypted_file</td><td>file_num</td><td>yes</td><td>generate_mnemonic, bip32_extended_master_key, decrypt_master_key, decrypt_mnemonic, seed_to_master_key, mnemonic_to_key or mnemonic_to_addresses -y &lt;file_num&gt;</td></tr>
<tr><td>-w, --overwrite</td><td>overwrite</td><td>no</td><td>generate_mnemonic or bip32_extended_master_key -w</td></tr>
<tr><td>-b, --silent</td><td>silent</td><td>no</td><td>generate_mnemonic or bip32_extended_master_key -b</td></tr>
<tr><td>-j, --use_tpm</td><td>use_tpm</td><td>no</td><td>generate_mnemonic, bip32_extended_master_key, decrypt_master_key, decrypt_mnemonic, seed_to_master_key, mnemonic_to_key or mnemonic_to_addresses -j</td></tr>
<tr><td>-t, --testnet</td><td>designate_testnet</td><td>no</td><td>generate_private_key -t</td></tr>
<tr><td>-s</td><td>script_hex</td><td>yes</td><td>comp2der -s &lt;compact_signature&gt;</td></tr>
<tr><td>-x</td><td>transaction_hex</td><td>yes</td><td>sign -x &lt;transaction_hex&gt; -s &lt;pubkey_script&gt; -i &lt;index_of_utxo_to_sign&gt; -h &lt;sig_hash_type&gt;</td></tr>
<tr><td>-i</td><td>input_index</td><td>yes</td><td>see above</td></tr>
<tr><td>-h</td><td>sighash_type</td><td>yes</td><td>see above</td></tr>
</tbody></table>
</div>
<p>Below is a list of all the commands and the flags that they require. As a reminder, any command that includes the <code>-t</code> flag will set the default chain used in internal calculations to <em>testnet</em> rather than <em>mainnet</em>. Also included are descriptions of what each function does.</p>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Required flags</th><th>Optional flags</th><th>Description</th></tr></thead><tbody>
<tr><td>generate_private_key</td><td>None</td><td>-t</td><td>Generates a private key from a secp256k1 context for either mainnet or testnet.</td></tr>
<tr><td>generate_public_key</td><td>-p</td><td>-t</td><td>Generates a public key derived from the private key specified. Include the testnet flag if it was generated from testnet.</td></tr>
<tr><td>p2pkh</td><td>-k</td><td>-t</td><td>Generates a p2pkh address derived from the public key specified. Include the testnet flag if it was generated from testnet.</td></tr>
<tr><td>bip32_extended_master_key</td><td>None</td><td>-t</td><td>Generate an extended master private key from a secp256k1 context for either mainnet or testnet.</td></tr>
<tr><td>bip32maintotest</td><td>-p</td><td>None</td><td>Convert a mainnet private key into an equivalent testnet key.</td></tr>
<tr><td>derive_child_keys</td><td>-p, -m</td><td>-t</td><td>Generates a child key derived from the specified public or private key using the specified derivation path.</td></tr>
<tr><td>generate_mnemonic</td><td>None</td><td>-e, -y, -w, -b</td><td>Generates a 24-word english seed phrase randomly or from optional hex entropy.</td></tr>
<tr><td>list_encryption_keys_in_tpm</td><td>None</td><td>None</td><td>List the encryption keys in the TPM.</td></tr>
<tr><td>decrypt_master_key</td><td>-y</td><td>-j</td><td>Decrypt the master key with the TPM or SW.</td></tr>
<tr><td>decrypt_mnemonic</td><td>-y</td><td>-j</td><td>Decrypt the mnemonic with the TPM or SW.</td></tr>
<tr><td>seed_to_master_key</td><td>-y</td><td>-j, -t</td><td>Generates an extended master private key from a seed for either mainnet or testnet.</td></tr>
<tr><td>mnemonic_to_key</td><td>-n</td><td>-a, -y, -o, g, -i, -t</td><td>Generates a private key from a seed phrase with a default path or specified account, change level and index for either mainnet or testnet.</td></tr>
<tr><td>mnemonic_to_addresses</td><td>-n</td><td>-a, -y, -o, g, -i, -t</td><td>Generates an address from a seed phrase with a default path or specified account, change level and index for either mainnet or testnet.</td></tr>
<tr><td>print_keys</td><td>-p</td><td>-t</td><td>Print all keys associated with the provided private key.</td></tr>
<tr><td>sign</td><td>-x, -s, -i, -h, -p</td><td>-t</td><td>See the definition of sign_raw_transaction in the Transaction API.</td></tr>
<tr><td>comp2der</td><td>-s</td><td>None</td><td>Convert a compact signature to a DER signature.</td></tr>
<tr><td>signmessage</td><td>-x, -p</td><td>None</td><td>Sign a message and output a base64 encoded signature and address.</td></tr>
<tr><td>verify_message</td><td>-x, -s, -k</td><td>None</td><td>Verify a message by public key recovery of base64 decoded signature and comparison of addresses.</td></tr>
<tr><td>transaction</td><td>None</td><td>None</td><td>Start the interactive transaction app. <a href="">Usage instructions below.</a></td></tr>
</tbody></table>
</div>
<p>Lastly, to display the version of <code>such</code>, simply run the following command, which overrides any previous ones specified:</p>
<pre><code>./such -v
</code></pre>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<p>Below are some examples on how to use the <code>such</code> tool in practice.</p>
<h5 id="generate-a-new-private-key-wif-and-hex-encoded"><a class="header" href="#generate-a-new-private-key-wif-and-hex-encoded">Generate a new private key WIF and hex encoded:</a></h5>
<pre><code>./such -c generate_private_key
&gt; privatekey WIF: QSPDnjzvrSPAeiM7N2jCkzv2dqsi7fxoHipgpPfz2zdE3ZpYp74j
&gt; privatekey HEX: 7073fa30281cf89195dca333134368d539e7abad712abb532c9eaf5f3666d9d1
</code></pre>
<h5 id="generate-the-public-key-p2pkh-and-p2sh-p2pkh-address-from-a-wif-encoded-private-key"><a class="header" href="#generate-the-public-key-p2pkh-and-p2sh-p2pkh-address-from-a-wif-encoded-private-key">Generate the public key, p2pkh, and p2sh-p2pkh address from a WIF encoded private key</a></h5>
<pre><code>./such -c generate_public_key -p QSPDnjzvrSPAeiM7N2jCkzv2dqsi7fxoHipgpPfz2zdE3ZpYp74j
&gt; pubkey: 02cf2c99c2db4b3d72d4289aa23bdaf5f3ccf4867ec8e5f8223ea716a7a3de10bc
&gt; p2pkh address: D62RKK6AGkzX6fM8RzoVM8fjPx2nzrdvKU
</code></pre>
<h5 id="generate-the-p2pkh-address-from-a-hex-encoded-compact-public-key"><a class="header" href="#generate-the-p2pkh-address-from-a-hex-encoded-compact-public-key">Generate the P2PKH address from a hex encoded compact public key</a></h5>
<pre><code>./such -c generate_public_key -pubkey 02cf2c99c2db4b3d72d4289aa23bdaf5f3ccf4867ec8e5f8223ea716a7a3de10bc
&gt; p2pkh address: D62RKK6AGkzX6fM8RzoVM8fjPx2nzrdvKU
</code></pre>
<h5 id="generate-new-bip32-master-key"><a class="header" href="#generate-new-bip32-master-key">Generate new BIP32 master key</a></h5>
<pre><code>./such -c bip32_extended_master_key
&gt; masterkey: dgpv51eADS3spNJh9qLpW8S7B7uZmusTpNE85NgXsYD7eGuVhebMDfEsj6fNR6DHgpSBCmYdAvw9YRSqRWnFxtYn1bM8AdNipwdi9dDXFCY8vkY
</code></pre>
<h5 id="print-hd-node"><a class="header" href="#print-hd-node">Print HD node</a></h5>
<pre><code>./such -c print_keys -privkey dgpv51eADS3spNJh9qLpW8S7B7uZmusTpNE85NgXsYD7eGuVhebMDfEsj6fNR6DHgpSBCmYdAvw9YRSqRWnFxtYn1bM8AdNipwdi9dDXFCY8vkY
&gt; ext key:             dgpv51eADS3spNJh9qLpW8S7B7uZmusTpNE85NgXsYD7eGuVhebMDfEsj6fNR6DHgpSBCmYdAvw9YRSqRWnFxtYn1bM8AdNipwdi9dDXFCY8vkY
&gt; extended pubkey:     dgub8kXBZ7ymNWy2SgzyYN45HyTAEUF6eVFqMyTk2ec6SPxWFhi3dRneNQ51zJadLERvA1ns9uvMGKM9wYKTSnCP9QrSPJMCKjdfSv4qmT3PkP2
&gt; pubkey hex:          025368ca428b4c4e0c48631c5f8510d704858a52c7264d4ba74f34b2bcee374220
&gt; privatekey WIF:      QTtXPXYWc4G6WuA6qNRYeQ3TAdsBUUqrLwN1eWVFEvfHdd8M1ed5
&gt; depth:               0
&gt; child index:         0
&gt; p2pkh address:       D79Q3spkucaM2DvLxUZjgV1X4cQcWDLuyt
</code></pre>
<h5 id="derive-child-key-second-child-key-at-level-1-in-this-case"><a class="header" href="#derive-child-key-second-child-key-at-level-1-in-this-case">Derive child key (second child key at level 1 in this case)</a></h5>
<pre><code>./such -c derive_child_keys -m m/1h -privkey dgpv51eADS3spNJh9qLpW8S7B7uZmusTpNE85NgXsYD7eGuVhebMDfEsj6fNR6DHgpSBCmYdAvw9YRSqRWnFxtYn1bM8AdNipwdi9dDXFCY8vkY
&gt; ext key:             dgpv53gfwGVYiKVgf3hybqGjXuxrW2s2iCArhBURxAWaFszfqfP6wc23KFVyCuGj4fGzAX6oC8QmvhvkWz18v4VcdhzYCxoTR3XQizrVtjMwQHS
&gt; extended pubkey:     dgub8nZhGxRSGUA1wuN8e4themWSxbEfYKCZynFe7GuZ413gPiVoMNZoxYucn8DQ5doeqt1cmZnxZ4Ms9SdsraiSbUkZSYbx1GzpGbrAqmFdSSL
&gt; pubkey hex:          023973b755fdaf5b2b7b20ac134c936ec7882b1ce0a3a75857fc490c12cdf4fb4f
&gt; privatekey WIF:      QQUwLsFpWWXsHFLCxjvBMn8Qd4Pgqji5QUXz6zN8vkiKMPvv7mpZ
&gt; depth:               1
&gt; child index:         -2147483647
&gt; p2pkh address:       DFqonEEA56VE8zEGvhXNgjiPT3PaPFNQQu
</code></pre>
<h5 id="derive-public-child-key-second-child-key-at-level-2-in-this-case-non-hardened"><a class="header" href="#derive-public-child-key-second-child-key-at-level-2-in-this-case-non-hardened">Derive public child key (second child key at level 2 in this case, non-hardened)</a></h5>
<pre><code>./such -c derive_child_keys -m m/1 -p dgub8sdBNNzYwKo1KKQcQoJXMDwEg3fgX52aY2aSuSGMXepn71kMtZoN7BVwWp7JT582EDT8djTpCMx7Nd62nJ8u8xNmszEXrmsHWf6XQccjiLg
&gt; ext key:             dgub8q9VuPpS4NijK4e7Cc7WaKGD6QHjUB3YkJi83imYVvBRGjrKwPcNFjNcmNt2UnEuhFmKhcmo8aRQABUhq55H3ackUBGj3nJDTMpcP6ALoiN
&gt; extended pubkey:     dgub8q9VuPpS4NijK4e7Cc7WaKGD6QHjUB3YkJi83imYVvBRGjrKwPcNFjNcmNt2UnEuhFmKhcmo8aRQABUhq55H3ackUBGj3nJDTMpcP6ALoiN
&gt; pubkey hex:          02cbfea5f5cf7d28b9111e92f05356a39a64f19247e539b428ef91e70a6900ae71
&gt; depth:               2
&gt; child index:         1
&gt; p2pkh address:       D7M52mS3ZTrPXgRmfjpV5pPSG2E2TsfZAi
</code></pre>
<h4 id="generate-a-random-bip39-seed-phrase"><a class="header" href="#generate-a-random-bip39-seed-phrase">Generate a random BIP39 seed phrase</a></h4>
<h4 id="see-seed-phrases-in-addressmd-for-additional-guidance"><a class="header" href="#see-seed-phrases-in-addressmd-for-additional-guidance">See "Seed phrases" in address.md, for additional guidance</a></h4>
<pre><code>./such -c generate_mnemonic
&gt; they nuclear observe moral twenty gym hedgehog damage reveal syrup negative beach best silk alone feel vapor deposit belt host purity run clever deer
</code></pre>
<h4 id="generate-a-hd-master-key-from-the-seed-phrase-for-a-given-account-2-change-level-1-internal-and-index-0-for-testnet"><a class="header" href="#generate-a-hd-master-key-from-the-seed-phrase-for-a-given-account-2-change-level-1-internal-and-index-0-for-testnet">Generate a HD master key from the seed phrase for a given account (2), change level (1, internal) and index (0) for testnet</a></h4>
<pre><code>./such -c mnemonic_to_key -n "they nuclear observe moral twenty gym hedgehog damage reveal syrup negative beach best silk alone feel vapor deposit belt host purity run clever deer" -o 2 -g 1 -i 0 -t
&gt; keypath: m/44'/1'/2'/1/0
&gt; private key (wif): cniAjMkD7HpzQKw67ByNsyzqMF8MEJo2y4viH2WEZRXoKHNih1sH
</code></pre>
<h4 id="generate-an-hd-address-from-the-seed-phrase-for-a-given-account-2-change-level-1-internal-and-index-0-for-testnet"><a class="header" href="#generate-an-hd-address-from-the-seed-phrase-for-a-given-account-2-change-level-1-internal-and-index-0-for-testnet">Generate an HD address from the seed phrase for a given account (2), change level (1, internal) and index (0) for testnet</a></h4>
<pre><code>./such -c mnemonic_to_addresses -n "they nuclear observe moral twenty gym hedgehog damage reveal syrup negative beach best silk alone feel vapor deposit belt host purity run clever deer" -o 2 -g 1 -i 0 -t
&gt; Address: nW7ndt4HZh8XwLYN6v6N2S4mZCbpZPuFxh
</code></pre>
<h4 id="generate-a-bip39-seed-phrase-from-hex-entropy"><a class="header" href="#generate-a-bip39-seed-phrase-from-hex-entropy">Generate a BIP39 seed phrase from hex entropy</a></h4>
<pre><code>./such -c generate_mnemonic -e "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
&gt; zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo vote
</code></pre>
<h4 id="geneate-an-hd-address-from-the-seed-phrase-and-default-path-m443000-for-mainnet"><a class="header" href="#geneate-an-hd-address-from-the-seed-phrase-and-default-path-m443000-for-mainnet">Geneate an HD address from the seed phrase and default path (m/44'/3'/0'/0/0) for mainnet</a></h4>
<pre><code>./such -c mnemonic_to_addresses -n "zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo zoo vote"
&gt; Address: DTdKu8YgcxoXyjFCDtCeKimaZzsK27rcwT
</code></pre>
<h4 id="sign-an-arbitrary-message"><a class="header" href="#sign-an-arbitrary-message">Sign an arbitrary message</a></h4>
<pre><code>./such -c signmessage -x bleh -p QWCcckTzUBiY1g3GFixihAscwHAKXeXY76v7Gcxhp3HUEAcBv33i
message: bleh
content: ICrbftD0KamyaB68IoXbeke3w4CpcIvv+Q4pncBNpMk8fF5+xsR9H9gqmfM0JrjlfzZZA3E8AJ0Nug1KWeoVw3g=
address: D8mQ2sKYpLbFCQLhGeHCPBmkLJRi6kRoSg
</code></pre>
<h4 id="verify-an-arbitrary-message"><a class="header" href="#verify-an-arbitrary-message">Verify an arbitrary message</a></h4>
<pre><code>./such -c verifymessage -x bleh -s ICrbftD0KamyaB68IoXbeke3w4CpcIvv+Q4pncBNpMk8fF5+xsR9H9gqmfM0JrjlfzZZA3E8AJ0Nug1KWeoVw3g= -k D8mQ2sKYpLbFCQLhGeHCPBmkLJRi6kRoSg
Message is verified!
</code></pre>
<h2 id="encrypted-mnemonics-key-and-seed-backups"><a class="header" href="#encrypted-mnemonics-key-and-seed-backups">Encrypted Mnemonics, Key and Seed Backups</a></h2>
<p>The <code>such</code> tool provides functionality to securely manage your encrypted mnemonics, key and seed backups. With the ability to generate mnemonics and encrypt them for safe storage, and to decrypt them when needed, managing your cryptographic assets is made easier. To use encrypted files with <code>spvnode</code>, you must first use the <code>such</code> tool to generate and encrypt your mnemonic or master key. You can then use the <code>spvnode</code> tool to import the encrypted file and use it to connect to the network.</p>
<h3 id="generating-and-encrypting-mnemonics"><a class="header" href="#generating-and-encrypting-mnemonics">Generating and Encrypting Mnemonics</a></h3>
<p>To generate a new mnemonic, which is a 24-word seed phrase, you can use the following command:</p>
<pre><code>./such -c generate_mnemonic
</code></pre>
<p>This will output a new mnemonic that you can use to generate keys and addresses. If you want to encrypt this mnemonic to keep it safe, you can use the following command:</p>
<pre><code>./such -c generate_mnemonic -y &lt;file_num&gt;
</code></pre>
<p>The <code>-y</code> flag is used to specify the file number to use for encryption. This number is used to identify the encrypted file when you need to decrypt it. You can also use the <code>-w</code> flag to overwrite an existing file with the same number. If you want to encrypt the mnemonic using a TPM (Trusted Platform Module), you can use the <code>-j</code> flag as shown:</p>
<pre><code>./such -c generate_mnemonic -y &lt;file_num&gt; -j
</code></pre>
<p>Replace <code>&lt;file_num&gt;</code> with the appropriate file number you want to use for encryption (e.g. 0, 1, 2, etc.). <code>999</code> is reserved for testing purposes.</p>
<p>Encrypting a mnemonic will output a file with the encrypted mnemonic. You can use the <code>-b</code> flag to suppress the mnemonic output and only output the encrypted file. This is useful if you want to encrypt a mnemonic and save it to a file without displaying the mnemonic on the screen. For example:</p>
<pre><code>./such -c generate_mnemonic -y &lt;file_num&gt; -b
</code></pre>
<p>All encryted files are saved in the store directory. On Linux, this is <code>.store</code> in the libdogecoin directory. On Windows, this is the <code>store</code> directory in the libdogecoin directory.</p>
<h3 id="decrypting-mnemonics"><a class="header" href="#decrypting-mnemonics">Decrypting Mnemonics</a></h3>
<p>When you need to access your encrypted mnemonic, you can decrypt it using the <code>decrypt_mnemonic</code> command. If the mnemonic was encrypted using TPM (Trusted Platform Module), you can use the <code>-j</code> flag as shown:</p>
<pre><code>./such -c decrypt_mnemonic -y &lt;file_num&gt; -j
</code></pre>
<p>Replace <code>&lt;file_num&gt;</code> with the appropriate file number you used during encryption.</p>
<h3 id="handling-key-backups"><a class="header" href="#handling-key-backups">Handling Key Backups</a></h3>
<p>You can also encrypt and decrypt your master key using similar commands. To encrypt a master key, you might first generate it and then encrypt as follows:</p>
<pre><code>./such -c bip32_extended_master_key -y &lt;file_num&gt; -j
</code></pre>
<p>And to decrypt it back when required:</p>
<pre><code>./such -c decrypt_master_key -y &lt;file_num&gt; -j
</code></pre>
<p>Always ensure to replace <code>&lt;file_num&gt;</code> with the actual number of the encrypted file.</p>
<h3 id="handling-seed-backups"><a class="header" href="#handling-seed-backups">Handling Seed Backups</a></h3>
<p>You can also decrypt your seed backups using the <code>seed_to_master_key</code> command. This command will decrypt the seed and generate a master key from it. If the seed was encrypted using TPM (Trusted Platform Module), you can use the <code>-j</code> flag as shown:</p>
<pre><code>./such -c seed_to_master_key -y &lt;file_num&gt; -j
</code></pre>
<h3 id="overwriting-encrypted-files"><a class="header" href="#overwriting-encrypted-files">Overwriting Encrypted Files</a></h3>
<p>If you want to overwrite an existing encrypted file, you can use the <code>-w</code> flag as shown:</p>
<pre><code>./such -c generate_mnemonic -y &lt;file_num&gt; -w
</code></pre>
<p>This will overwrite the existing file with the same number. You can also use the <code>-w</code> flag with the <code>bip32_extended_master_key</code> command to overwrite an existing encrypted master key.</p>
<h3 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h3>
<ul>
<li><strong>Backup</strong>: Always backup your encrypted files in multiple secure locations. Adhering to the "rule of three" is advised, meaning you should have three copies of your data: the original, a primary backup, and a secondary backup, ideally kept in different locations to mitigate the risk of data loss due to environmental factors.</li>
<li><strong>File Numbers</strong>: Encrypting files with the same file number will overwrite the previous file with the same number of that type. This is useful for overwriting old backups with new ones, but can be dangerous if you accidentally overwrite a file you need. Always keep track of your file numbers and what they are used for.</li>
<li><strong>Security</strong>: Use a TPM where available for added security during encryption and decryption processes.  Encryption keys are stored in the TPM and never leave the TPM.  The TPM is a hardware device that is designed to be tamper resistant.  If you do not have a TPM, you can use software encryption and decryption, but this is less secure than using a TPM.</li>
<li><strong>Overwrites</strong>: Overwriting encrypted files is irreversible. Files and backups encrypted with TPM cannot be decrypted once overwritten.  Files and backups encrypted with software can be decrypted with software, but the original file will be lost.</li>
</ul>
<h3 id="important-notes-general"><a class="header" href="#important-notes-general">Important Notes (General)</a></h3>
<ul>
<li>
<p><strong>If you lose your encrypted files, you will not be able to decrypt your mnemonics or master keys.</strong></p>
</li>
<li>
<p><strong>If you lose your mnemonic or master key, you will not be able to recover your coins.</strong></p>
</li>
<li>
<p><strong>Overwriting encrypted files is irreversible.</strong></p>
</li>
</ul>
<h3 id="important-notes-tpm-specific"><a class="header" href="#important-notes-tpm-specific">Important Notes (TPM-specific)</a></h3>
<ul>
<li>
<p><strong>If you lose your TPM, you will not be able to decrypt your mnemonics or master keys.</strong></p>
</li>
<li>
<p><strong>TPM encrypted files cannot be decrypted with software.</strong></p>
</li>
</ul>
<p>These commands and flags are part of the <code>such</code> CLI tool's functionality, enabling a robust management system for your encrypted data within the Libdogecoin ecosystem.</p>
<h3 id="interactive-transaction-building-with-such"><a class="header" href="#interactive-transaction-building-with-such">Interactive Transaction Building with <code>such</code></a></h3>
<p>When you start the interactive <code>such</code> transaction tool with <code>./such -c transaction</code>, you will be faced with a menu of options. To choose one of these options to execute, simply type the number of that command and hit enter.</p>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td>add transaction</td><td>Start building a new transaction.</td></tr>
<tr><td>edit transaction by id</td><td>Make changes to a transaction that has already been started.</td></tr>
<tr><td>find transaction</td><td>Print out the hex of a transaction that has already been started.</td></tr>
<tr><td>sign transaction</td><td>Sign the inputs of a finalized transaction.</td></tr>
<tr><td>delete transaction</td><td>Remove an existing transaction from memory.</td></tr>
<tr><td>delete all transactions</td><td>Remove all existing transactions from memory.</td></tr>
<tr><td>print transactions</td><td>Start building a new transaction.</td></tr>
<tr><td>import raw transaction</td><td>Saves the entered transaction hex as a transaction object in memory.</td></tr>
<tr><td>broadcast transaction</td><td>Performs the same operation as [<code>./sendtx</code>] (#the-sendtx-tool) (<code>sendtx</code> recommended)</td></tr>
<tr><td>change network</td><td>Specify the network for building transactions.</td></tr>
<tr><td>quit</td><td>Exit the tool.</td></tr>
</tbody></table>
</div>
<p>Once you choose a command, there will be on-screen prompts to guide your next actions. All of these commands internally call the functions that make up Libdogecoin, so for more information on what happens when these commands are run, please refer to the <a href="doc/../transaction.html">Libdogecoin Essential Transaction API</a>.</p>
<h2 id="the-sendtx-tool"><a class="header" href="#the-sendtx-tool">The <code>sendtx</code> Tool</a></h2>
<p>Now that you've built a sendable transaction with Libdogecoin, <code>sendtx</code> is here to broadcast that transaction so that it can be published on the blockchain. You can broadcast to peers retrieved from a DNS seed or specify with IP/port. The application will try to connect to a default maximum of 10 peers, send the transaction to two of them, and listen on the remaining ones if the transaction has been relayed back. Alongside Libdogecoin, <code>sendtx</code> gives you the capability to publish your own transactions directly to the blockchain without using external services.</p>
<h3 id="usage-1"><a class="header" href="#usage-1">Usage</a></h3>
<p>Similar to <code>such</code>, <code>sendtx</code> is simple to run and is invoked by simply running the command <code>./sendtx</code> in the top level of the Libdogecoin directory, which is then simply followed by the transaction hex to broadcast rather than a command like in <code>such</code>. There are still several flags that may be helpful</p>
<div class="table-wrapper"><table><thead><tr><th>Flag</th><th>Name</th><th>Required Arg?</th><th>Usage</th></tr></thead><tbody>
<tr><td>-t, --testnet</td><td>designate_testnet</td><td>no</td><td>./sendtx -t &lt;tx_hex_for_testnet&gt;</td></tr>
<tr><td>-r, --regtest</td><td>designate_regtest</td><td>no</td><td>./sendtx -r &lt;tx_hex_for_regtest&gt;</td></tr>
<tr><td>-d, --debug</td><td>designate_debug</td><td>no</td><td>./sendtx -d &lt;tx_hex&gt;</td></tr>
<tr><td>-s, --timeout</td><td>timeout_threshold</td><td>yes</td><td>./sendtx -s 10 &lt;tx_hex&gt;</td></tr>
<tr><td>-i, --ips</td><td>ip_addresses</td><td>yes</td><td>./sendtx -i 127.0.0.1:22556,192.168.0.1:22556 &lt;tx_hex&gt;</td></tr>
<tr><td>-m, --maxnodes</td><td>max_connected_nodes</td><td>yes</td><td>./sendtx -m 6 &lt;tx_hex&gt;</td></tr>
</tbody></table>
</div>
<p>Lastly, to display only the version of <code>sendtx</code>, simply run the following command:</p>
<pre><code>./sendtx -v
</code></pre>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<p>Below are some examples on how to use the <code>sendtx</code> tool in practice.</p>
<h5 id="send-a-raw-transaction-to-random-peers-on-mainnet"><a class="header" href="#send-a-raw-transaction-to-random-peers-on-mainnet">Send a raw transaction to random peers on mainnet</a></h5>
<pre><code>./sendtx &lt;tx_hex&gt;
</code></pre>
<h5 id="send-a-raw-transaction-to-random-peers-on-testnet-and-show-debug-information"><a class="header" href="#send-a-raw-transaction-to-random-peers-on-testnet-and-show-debug-information">Send a raw transaction to random peers on testnet and show debug information</a></h5>
<pre><code>./sendtx -d -t &lt;tx_hex&gt;
</code></pre>
<h5 id="send-a-raw-transaction-to-specific-peers-on-mainnet-and-show-debug-information-using-a-timeout-of-5s"><a class="header" href="#send-a-raw-transaction-to-specific-peers-on-mainnet-and-show-debug-information-using-a-timeout-of-5s">Send a raw transaction to specific peers on mainnet and show debug information using a timeout of 5s</a></h5>
<pre><code>./sendtx -d -s 5 -i 192.168.1.110:22556,127.0.0.1:22556 &lt;tx_hex&gt;
</code></pre>
<h5 id="send-a-raw-transaction-to-at-most-5-random-peers-on-mainnet"><a class="header" href="#send-a-raw-transaction-to-at-most-5-random-peers-on-mainnet">Send a raw transaction to at most 5 random peers on mainnet</a></h5>
<pre><code>./sendtx -m 5 &lt;tx_hex&gt;
</code></pre>
<h2 id="the-spvnode-tool"><a class="header" href="#the-spvnode-tool">The <code>spvnode</code> Tool</a></h2>
<p><code>spvnode</code> is a command-line tool that operates a Simple Payment Verification (SPV) node for the Dogecoin blockchain. It enables users to interact with the Dogecoin network, verify transactions, and stay in sync with the blockchain.</p>
<h3 id="operation-modes"><a class="header" href="#operation-modes">Operation Modes</a></h3>
<p><code>spvnode</code> supports two operational modes:</p>
<ol>
<li>
<p><strong>Header-Only Mode</strong>: This mode is for quickly catching up with the blockchain by downloading only the block headers. This mode is typically used for initial sync, and then the node can switch to full block mode for verifying transactions.</p>
</li>
<li>
<p><strong>Full Block Mode</strong>: After catching up with the blockchain headers, <code>spvnode</code> can switch to this mode to download full blocks for detailed transaction history scanning. This is essential for verifying transactions related to the user's wallet addresses.</p>
</li>
</ol>
<h3 id="usage-2"><a class="header" href="#usage-2">Usage</a></h3>
<p>To use <code>spvnode</code>, execute it from the top level of the Libdogecoin directory. Start the tool by running <code>./spvnode</code> followed by the <code>scan</code> command. There are several flags that can be used to customize the behavior of <code>spvnode</code>:</p>
<p>Each flag is accompanied by a description and usage example. To view the version of <code>spvnode</code>, simply run:</p>
<pre><code>./spvnode -v
</code></pre>
<p>Run <code>spvnode</code> in header-only mode for a fast catch-up:</p>
<pre><code>./spvnode scan
</code></pre>
<p>To activate full block validation mode for comprehensive address scanning, include the -b flag:</p>
<pre><code>./spvnode -b scan
</code></pre>
<p>To utilize checkpoints for faster initial sync, apply the -p flag:</p>
<pre><code>./spvnode -p scan
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Flag</th><th>Name</th><th>Required Arg?</th><th>Usage</th></tr></thead><tbody>
<tr><td><code>-t</code>, <code>--testnet</code></td><td>Testnet Mode</td><td>No</td><td>Activate testnet: <code>./spvnode -t scan</code></td></tr>
<tr><td><code>-r</code>, <code>--regtest</code></td><td>Regtest Mode</td><td>No</td><td>Activate regtest network: <code>./spvnode -r scan</code></td></tr>
<tr><td><code>-i</code>, <code>--ips</code></td><td>Initial Peers</td><td>Yes</td><td>Specify initial peers: <code>./spvnode -i 127.0.0.1:22556 scan</code></td></tr>
<tr><td><code>-d</code>, <code>--debug</code></td><td>Debug Mode</td><td>No</td><td>Enable debug output: <code>./spvnode -d scan</code></td></tr>
<tr><td><code>-m</code>, <code>--maxnodes</code></td><td>Max Peers</td><td>No</td><td>Set max peers: <code>./spvnode -m 8 scan</code></td></tr>
<tr><td><code>-a</code>, <code>--address</code></td><td>Address</td><td>Yes</td><td>Use address: <code>./spvnode -a "your address here" scan</code></td></tr>
<tr><td><code>-n</code>, <code>--mnemonic</code></td><td>Mnemonic Seed</td><td>Yes</td><td>Use BIP39 mnemonic: <code>./spvnode -n "your mnemonic here" scan</code></td></tr>
<tr><td><code>-s</code>, <code>--pass_phrase</code></td><td>Passphrase</td><td>No</td><td>Passphrase for BIP39 seed: <code>./spvnode -s scan</code></td></tr>
<tr><td><code>-f</code>, <code>--dbfile</code></td><td>Database File</td><td>No</td><td>Headers DB file/mem-only (0): <code>./spvnode -f 0 scan</code></td></tr>
<tr><td><code>-c</code>, <code>--continuous</code></td><td>Continuous Mode</td><td>No</td><td>Run continuously: <code>./spvnode -c scan</code></td></tr>
<tr><td><code>-b</code>, <code>--full_sync</code></td><td>Full Sync</td><td>No</td><td>Perform a full sync: <code>./spvnode -b scan</code></td></tr>
<tr><td><code>-p</code>, <code>--checkpoint</code></td><td>Checkpoint</td><td>No</td><td>Enable checkpoint sync: <code>./spvnode -p scan</code></td></tr>
<tr><td><code>-w</code>, <code>--wallet_file</code></td><td>Wallet File</td><td>Yes</td><td>Specify wallet file: <code>./spvnode -w "./wallet.db" scan</code></td></tr>
<tr><td><code>-h</code>, <code>--headers_file</code></td><td>Headers File</td><td>Yes</td><td>Specify headers DB file: <code>./spvnode -h "./headers.db" scan</code></td></tr>
<tr><td><code>-l</code>, <code>--no_prompt</code></td><td>No Prompt</td><td>No</td><td>Load wallet and headers without prompt: <code>./spvnode -l scan</code></td></tr>
<tr><td><code>-y</code>, <code>--encrypted_file</code></td><td>Encrypted File</td><td>Yes</td><td>Use encrypted file: <code>./spvnode -y 0 scan</code></td></tr>
<tr><td><code>-j</code>, <code>--use_tpm</code></td><td>Use TPM</td><td>No</td><td>Utilize TPM for decryption: <code>./spvnode -j scan</code></td></tr>
<tr><td><code>-k</code>, <code>--master_key</code></td><td>Master Key</td><td>No</td><td>Use master key decryption: <code>./spvnode -k scan</code></td></tr>
<tr><td><code>-z</code>, <code>--daemon</code></td><td>Daemon Mode</td><td>No</td><td>Run as a daemon: <code>./spvnode -z scan</code></td></tr>
</tbody></table>
</div>
<h3 id="commands"><a class="header" href="#commands">Commands</a></h3>
<p>The primary command for <code>spvnode</code> is <code>scan</code>, which syncs the blockchain headers:</p>
<h4 id="scan"><a class="header" href="#scan"><code>scan</code></a></h4>
<p>Connects to the Dogecoin network and synchronizes the blockchain headers to the local database.</p>
<h3 id="callback-functions"><a class="header" href="#callback-functions">Callback Functions</a></h3>
<p>The tool provides several callbacks for custom integration:</p>
<ul>
<li><code>spv_header_message_processed</code>: Triggered when a header is processed.</li>
<li><code>spv_sync_completed</code>: Invoked upon completion of the sync process.</li>
</ul>
<h3 id="best-practices-and-notes"><a class="header" href="#best-practices-and-notes">Best Practices and Notes</a></h3>
<p>When not specifying -w, spvnode will default to using main_wallet.db. To prevent unintended interactions with main_wallet.db, it's important to be consistent with the use of flags. The best practice is to always use -w and specify a distinct wallet file, especially when using new mnemonics or keys.</p>
<p>When using -n with a mnemonic, instead of main_wallet.db, spvnode will generate main_mnemonic_wallet.db.</p>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h4 id="sync-up-to-the-chain-tip-and-stores-all-headers-in-headersdb-quit-once-synced"><a class="header" href="#sync-up-to-the-chain-tip-and-stores-all-headers-in-headersdb-quit-once-synced">Sync up to the chain tip and stores all headers in <code>headers.db</code> (quit once synced):</a></h4>
<pre><code>./spvnode scan
</code></pre>
<h4 id="sync-up-to-the-chain-tip-and-give-some-debug-output-during-that-process"><a class="header" href="#sync-up-to-the-chain-tip-and-give-some-debug-output-during-that-process">Sync up to the chain tip and give some debug output during that process:</a></h4>
<pre><code>./spvnode -d scan
</code></pre>
<h4 id="sync-up-show-debug-info-dont-store-headers-in-file-only-in-memory-wait-for-new-blocks"><a class="header" href="#sync-up-show-debug-info-dont-store-headers-in-file-only-in-memory-wait-for-new-blocks">Sync up, show debug info, don't store headers in file (only in memory), wait for new blocks:</a></h4>
<pre><code>./spvnode -d -f 0 -c -b scan
</code></pre>
<h4 id="sync-up-with-an-address-show-debug-info-dont-store-headers-in-file-wait-for-new-blocks"><a class="header" href="#sync-up-with-an-address-show-debug-info-dont-store-headers-in-file-wait-for-new-blocks">Sync up, with an address, show debug info, don't store headers in file, wait for new blocks:</a></h4>
<pre><code>./spvnode -d -f 0 -c -a "DSVw8wkkTXccdq78etZ3UwELrmpfvAiVt1" -b scan
</code></pre>
<h4 id="sync-up-with-a-wallet-file-main_walletdb-show-debug-info-dont-store-headers-in-file-wait-for-new-blocks"><a class="header" href="#sync-up-with-a-wallet-file-main_walletdb-show-debug-info-dont-store-headers-in-file-wait-for-new-blocks">Sync up, with a wallet file "main_wallet.db", show debug info, don't store headers in file, wait for new blocks:</a></h4>
<pre><code>./spvnode -d -f 0 -c -w "./main_wallet.db" -b scan
</code></pre>
<h4 id="sync-up-with-a-wallet-file-main_walletdb-show-debug-info-with-a-headers-file-main_headersdb-wait-for-new-blocks"><a class="header" href="#sync-up-with-a-wallet-file-main_walletdb-show-debug-info-with-a-headers-file-main_headersdb-wait-for-new-blocks">Sync up, with a wallet file "main_wallet.db", show debug info, with a headers file "main_headers.db", wait for new blocks:</a></h4>
<pre><code>./spvnode -d -c -w "./main_wallet.db" -h "./main_headers.db" -b scan
</code></pre>
<h4 id="sync-up-with-a-wallet-file-main_walletdb-with-an-address-show-debug-info-with-a-headers-file-with-a-headers-file-main_headersdb-wait-for-new-blocks"><a class="header" href="#sync-up-with-a-wallet-file-main_walletdb-with-an-address-show-debug-info-with-a-headers-file-with-a-headers-file-main_headersdb-wait-for-new-blocks">Sync up, with a wallet file "main_wallet.db", with an address, show debug info, with a headers file, with a headers file "main_headers.db", wait for new blocks:</a></h4>
<pre><code>./spvnode -d -c -a "DSVw8wkkTXccdq78etZ3UwELrmpfvAiVt1" -w "./main_wallet.db" -h "./main_headers.db" -b scan
</code></pre>
<h4 id="sync-up-with-encrypted-mnemonic-0-show-debug-info-dont-store-headers-in-file-wait-for-new-blocks"><a class="header" href="#sync-up-with-encrypted-mnemonic-0-show-debug-info-dont-store-headers-in-file-wait-for-new-blocks">Sync up, with encrypted mnemonic 0, show debug info, don't store headers in file, wait for new blocks:</a></h4>
<pre><code>./spvnode -d -f 0 -c -y 0 -b scan
</code></pre>
<h4 id="sync-up-with-encrypted-mnemonic-0-bip39-passphrase-show-debug-info-dont-store-headers-in-file-wait-for-new-blocks"><a class="header" href="#sync-up-with-encrypted-mnemonic-0-bip39-passphrase-show-debug-info-dont-store-headers-in-file-wait-for-new-blocks">Sync up, with encrypted mnemonic 0, BIP39 passphrase, show debug info, don't store headers in file, wait for new blocks:</a></h4>
<pre><code>./spvnode -d -f 0 -c -y 0 -s -b scan
</code></pre>
<h4 id="sync-up-with-encrypted-mnemonic-0-bip39-passphrase-show-debug-info-dont-store-headers-in-file-wait-for-new-blocks-use-tpm"><a class="header" href="#sync-up-with-encrypted-mnemonic-0-bip39-passphrase-show-debug-info-dont-store-headers-in-file-wait-for-new-blocks-use-tpm">Sync up, with encrypted mnemonic 0, BIP39 passphrase, show debug info, don't store headers in file, wait for new blocks, use TPM:</a></h4>
<pre><code>./spvnode -d -f 0 -c -y 0 -s -j -b scan
</code></pre>
<h4 id="sync-up-with-encrypted-key-0-show-debug-info-dont-store-headers-in-file-wait-for-new-blocks-use-master-key"><a class="header" href="#sync-up-with-encrypted-key-0-show-debug-info-dont-store-headers-in-file-wait-for-new-blocks-use-master-key">Sync up, with encrypted key 0, show debug info, don't store headers in file, wait for new blocks, use master key:</a></h4>
<pre><code>./spvnode -d -f 0 -c -y 0 -k -b scan
</code></pre>
<h4 id="sync-up-with-encrypted-key-0-show-debug-info-dont-store-headers-in-file-wait-for-new-blocks-use-master-key-use-tpm"><a class="header" href="#sync-up-with-encrypted-key-0-show-debug-info-dont-store-headers-in-file-wait-for-new-blocks-use-master-key-use-tpm">Sync up, with encrypted key 0, show debug info, don't store headers in file, wait for new blocks, use master key, use TPM:</a></h4>
<pre><code>./spvnode -d -f 0 -c -y 0 -k -j -b scan
</code></pre>
<h4 id="sync-up-with-mnemonic-test-bip39-passphrase-show-debug-info-dont-store-headers-in-file-wait-for-new-blocks"><a class="header" href="#sync-up-with-mnemonic-test-bip39-passphrase-show-debug-info-dont-store-headers-in-file-wait-for-new-blocks">Sync up, with mnemonic "test", BIP39 passphrase, show debug info, don't store headers in file, wait for new blocks:</a></h4>
<pre><code>./spvnode -d -f 0 -c -n "test" -s -b scan
</code></pre>
<h4 id="sync-up-with-a-wallet-file-main_walletdb-with-encrypted-mnemonic-0-show-debug-info-dont-store-headers-in-file-wait-for-new-blocks"><a class="header" href="#sync-up-with-a-wallet-file-main_walletdb-with-encrypted-mnemonic-0-show-debug-info-dont-store-headers-in-file-wait-for-new-blocks">Sync up, with a wallet file "main_wallet.db", with encrypted mnemonic 0, show debug info, don't store headers in file, wait for new blocks:</a></h4>
<pre><code>./spvnode -d -f 0 -c -w "./main_wallet.db" -y 0 -b scan
</code></pre>
<h4 id="sync-up-with-a-wallet-file-main_walletdb-with-encrypted-mnemonic-0-show-debug-info-with-a-headers-file-main_headersdb-wait-for-new-blocks"><a class="header" href="#sync-up-with-a-wallet-file-main_walletdb-with-encrypted-mnemonic-0-show-debug-info-with-a-headers-file-main_headersdb-wait-for-new-blocks">Sync up, with a wallet file "main_wallet.db", with encrypted mnemonic 0, show debug info, with a headers file "main_headers.db", wait for new blocks:</a></h4>
<pre><code>./spvnode -d -c -w "./main_wallet.db" -h "./main_headers.db" -y 0 -b scan
</code></pre>
<h4 id="sync-up-with-a-wallet-file-main_walletdb-with-encrypted-mnemonic-0-show-debug-info-with-a-headers-file-main_headersdb-wait-for-new-blocks-use-tpm"><a class="header" href="#sync-up-with-a-wallet-file-main_walletdb-with-encrypted-mnemonic-0-show-debug-info-with-a-headers-file-main_headersdb-wait-for-new-blocks-use-tpm">Sync up, with a wallet file "main_wallet.db", with encrypted mnemonic 0, show debug info, with a headers file "main_headers.db", wait for new blocks, use TPM:</a></h4>
<pre><code>./spvnode -d -c -w "./main_wallet.db" -h "./main_headers.db" -y 0 -j -b scan
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libdogecoin-transaction-api"><a class="header" href="#libdogecoin-transaction-api">Libdogecoin Transaction API</a></h1>
<h2 id="table-of-contents-5"><a class="header" href="#table-of-contents-5">Table of Contents</a></h2>
<ul>
<li><a href="transaction.html#libdogecoin-transaction-api">Libdogecoin Transaction API</a>
<ul>
<li><a href="transaction.html#table-of-contents">Table of Contents</a></li>
<li><a href="transaction.html#introduction">Introduction</a></li>
<li><a href="transaction.html#working-transaction-api">Working Transaction API</a>
<ul>
<li><a href="transaction.html#new_transaction"><strong>new_transaction</strong></a></li>
<li><a href="transaction.html#add_transaction"><strong>add_transaction</strong></a></li>
<li><a href="transaction.html#find_transaction"><strong>find_transaction</strong></a></li>
<li><a href="transaction.html#remove_transaction"><strong>remove_transaction</strong></a></li>
</ul>
</li>
<li><a href="transaction.html#essential-transaction-api">Essential Transaction API</a>
<ul>
<li><a href="transaction.html#start_transaction"><strong>start_transaction</strong></a></li>
<li><a href="transaction.html#add_utxo"><strong>add_utxo</strong></a></li>
<li><a href="transaction.html#add_output"><strong>add_output</strong></a></li>
<li><a href="transaction.html#finalize_transaction"><strong>finalize_transaction</strong></a></li>
<li><a href="transaction.html#finalize_transaction_ex"><strong>finalize_transaction_ex</strong></a></li>
<li><a href="transaction.html#get_raw_transaction"><strong>get_raw_transaction</strong></a></li>
<li><a href="transaction.html#get_raw_transaction_ex"><strong>get_raw_transaction_ex</strong></a></li>
<li><a href="transaction.html#clear_transaction"><strong>clear_transaction</strong></a></li>
<li><a href="transaction.html#sign_raw_transaction"><strong>sign_raw_transaction</strong></a></li>
<li><a href="transaction.html#sign_raw_transaction_ex"><strong>sign_raw_transaction_ex</strong></a></li>
<li><a href="transaction.html#sign_transaction"><strong>sign_transaction</strong></a></li>
<li><a href="transaction.html#store_raw_transaction"><strong>store_raw_transaction</strong></a></li>
<li><a href="transaction.html#sign_indexed_raw_transaction_ex"><strong>sign_indexed_raw_transaction_ex</strong></a></li>
<li><a href="transaction.html#sign_transaction_ex"><strong>sign_transaction_ex</strong></a></li>
<li><a href="transaction.html#sign_transaction_w_privkey_ex"><strong>sign_transaction_w_privkey_ex</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>The high level 'essential' API provided by libdogecoin for working with simple transactions revolve around a structure defined as a <code>working_transaction</code> which is comprised of an index as an integer meant for retrieval, a dogecoin_tx 'transaction' structure as seen above, and finally a UT_hash_handle which stores our working_transaction struct in a hash table (using Troy D. Hanson's uthash library: see ./include/dogecoin/uthash.h and visit https://troydhanson.github.io/uthash/ for more information) which allow us to generate multiple transactions per "session". This <code>working_transaction</code> structure is defined as such:</p>
<pre><code class="language-C">typedef struct working_transaction {
    int index;
    dogecoin_tx* transaction;
    UT_hash_handle hh;
} working_transaction;
</code></pre>
<p>The functions that have been built around this <code>working_transaction</code> structure and flow of operation are comprised of 4 macros, which are explained further in the following section describing the <a href="transaction.html#working-transaction-api">working transaction API</a>. used to interact with uthash. For more detailed technical information about the <code>dogecoin_tx</code> structure and Dogecoin transactions in general, please refer to the <a href="./transaction_extended.html">extended transaction documentation</a>.</p>
<p>The api itself is a higher level interface that contains all the necessary operations for building Dogecoin transactions from scratch. The generic process for building a transaction is as follows:</p>
<ul>
<li>Create an empty transaction.</li>
<li>Add inputs from your wallet's UTXOs.</li>
<li>Add outputs describing amount and recipient.</li>
<li>Return any leftover change back to your address.</li>
<li>Sign all inputs with your wallet's private key.</li>
</ul>
<p>All of these steps can be done purely with Libdogecoin API, by calling directly from C and including the "libdogecoin.h" header file. For details on the usage of this API, jump to the <a href="transaction.html#essential-transaction-api">Essential API</a> section.</p>
<h2 id="working-transaction-api"><a class="header" href="#working-transaction-api">Working Transaction API</a></h2>
<p>These functions are designed to be "under the hood" and obfuscated from the end user as you will see in the Essential functions later on. They are to be used for manipulating the hash table which stores transactions in memory, and are already implemented within the Essential functions, so there is no need to call them again.</p>
<hr />
<h3 id="new_transaction"><a class="header" href="#new_transaction"><strong>new_transaction</strong></a></h3>
<p><code>working_transaction* new_transaction()</code></p>
<p>This function instantiates a new working_transaction structure for use. It allocates memory using <code>dogecoin_calloc()</code>, auto increments the index, instantiates a new dogecoin_tx structure, adds the working_transaction to the hash table and finally returns a pointer to the newly created working_transaction.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">working_transaction* transaction = new_transaction();
</code></pre>
<hr />
<h3 id="add_transaction"><a class="header" href="#add_transaction"><strong>add_transaction</strong></a></h3>
<p><code>void add_transaction(working_transaction *working_tx)</code></p>
<p>This function takes a working_transaction generated from <code>new_transaction()</code> and adds it to the hash table.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">working_transaction* working_tx = new_transaction();
add_transaction(working_tx);
</code></pre>
<hr />
<h3 id="find_transaction"><a class="header" href="#find_transaction"><strong>find_transaction</strong></a></h3>
<p><code>working_transaction* find_transaction(int idx)</code></p>
<p>This function returns a pointer to the working transaction at the specified index. If no transaction exists at that index, the function will return a NULL pointer.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">working_transaction* working_tx = find_transaction(1);
</code></pre>
<hr />
<h3 id="remove_transaction"><a class="header" href="#remove_transaction"><strong>remove_transaction</strong></a></h3>
<p><code>void remove_transaction(working_transaction *working_tx)</code></p>
<p>This function removes a working_transaction from the hash table and deallocates all memory dedicated to the working_transaction and the objects it contains using <code>dogecoin_free()</code>.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">working_transaction* working_tx = find_transaction(1);
remove_transaction(working_tx);
</code></pre>
<h2 id="essential-transaction-api"><a class="header" href="#essential-transaction-api">Essential Transaction API</a></h2>
<p>These functions implement the core functionality of Libdogecoin for building transactions, and are described in depth below. You can access them through a C program, by including the <code>libdogecoin.h</code> header in the source code and including the <code>libdogecoin.a</code> library at compile time.</p>
<hr />
<h3 id="start_transaction"><a class="header" href="#start_transaction"><strong>start_transaction</strong></a></h3>
<p><code>int start_transaction()</code></p>
<p>This function instantiates a new working_transaction structure and returns its index for future retrieval as an integer. This new working_transaction will contain an empty hex, which is "01000000000000000000". Note that anytime a new working transaction is created, it must also be removed at the end of the session by calling either <code>clear_transaction()</code>, otherwise a memory leak may occur.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"

int main() {
    int index = start_transaction();
    // build onto the working transaction here
    clear_transaction(index);
}
</code></pre>
<hr />
<h3 id="add_utxo"><a class="header" href="#add_utxo"><strong>add_utxo</strong></a></h3>
<p><code>int add_utxo(int txindex, char* hex_utxo_txid, int vout)</code></p>
<p>An unspent transaction output (utxo) is an output of a previous transaction in which funds were sent to the user's address. These can be spent by including them as inputs in a new transaction. This function takes in a working_transaction's index as an integer (txindex), a raw hexadecimal string id of the transaction containing the utxo to spend (hex_utxo_txid), and index of the desired utxo within the previous transaction's list of outputs (vout). The utxo is then added to the working_transaction-&gt;transaction-&gt;vin field, returning either 1 for success or 0 for failure.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"

int main() {
    char* prev_output_txid = "b4455e7b7b7acb51fb6feba7a2702c42a5100f61f61abafa31851ed6ae076074"; // worth 2 dogecoin
    int prev_output_n = 1;

    int index = start_transaction();
    if (!add_utxo(index, prev_output_txid, prev_output_n)) {
        // handle failure, return false; or printf("failure\n"); etc...
    }
    clear_transaction(index);
}
</code></pre>
<hr />
<h3 id="add_output"><a class="header" href="#add_output"><strong>add_output</strong></a></h3>
<p><code>int add_output(int txindex, char* destinationaddress, char* amount)</code></p>
<p>In order to actually spend utxos, the user must specify the new recipient address and how much of the total input amount will be sent to this address. This function takes in a working_transaction's index as an integer (txindex), the string p2pkh address of the new recipient (destinationaddress), and the amount in Dogecoin (amount) to send. This new output will be added to the working_transaction-&gt;transaction-&gt;vout field, returning either 1 for success or 0 for failure.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"

int main() {
    char* prev_output_txid = "42113bdc65fc2943cf0359ea1a24ced0b6b0b5290db4c63a3329c6601c4616e2"; // worth 10 dogecoin
    int prev_output_n = 1;
    char* external_address = "nbGfXLskPh7eM1iG5zz5EfDkkNTo9TRmde";

    int index = start_transaction();
    add_utxo(index, prev_output_txid, prev_output_n);
    if (!add_output(index, external_address, "5.0")) { // 5 dogecoin to be sent
        // error handling here
    }
    clear_transaction(index);
}
</code></pre>
<hr />
<h3 id="finalize_transaction"><a class="header" href="#finalize_transaction"><strong>finalize_transaction</strong></a></h3>
<p><code>char* finalize_transaction(int txindex, char* destinationaddress, char* subtractedfee, char* out_dogeamount_for_verification, char* changeaddress)</code></p>
<p>Because Dogecoin protocol requires that utxos must be spent in full, an additional output is usually included in a transaction to return all the leftover funds to the sender. This function automatically handles both creating this extra output and reserving some funds for the network fee. It takes in a working_transaction's index as an integer (txindex), the external destination address we are sending to (destinationaddress), the desired fee to be subtracted (subtractedfee), the total amount of all inputs included through <code>add_utxo()</code> (out_dogeamount_for_verification), and the public key of the sender (public_key). In addition to making change and deducting the fee, it checks that all of the recipients included in the transaction outputs are valid by converting their script hashes to p2pkh, and returns false if any are not found. Otherwise, the hex of the finalized transaction is returned as a string.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
    char* prev_output_txid_2 = "b4455e7b7b7acb51fb6feba7a2702c42a5100f61f61abafa31851ed6ae076074"; // worth 2 dogecoin
    char* prev_output_txid_10 = "42113bdc65fc2943cf0359ea1a24ced0b6b0b5290db4c63a3329c6601c4616e2"; // worth 10 dogecoin
    int prev_output_n_2 = 1;
    int prev_output_n_10 = 1;
    char* external_address = "nbGfXLskPh7eM1iG5zz5EfDkkNTo9TRmde";
    char* my_address = "noxKJyGPugPRN4wqvrwsrtYXuQCk7yQEsy";

    int index = start_transaction();
    add_utxo(index, prev_output_txid_2, prev_output_n_2);
    add_utxo(index, prev_output_txid_10, prev_output_n_10);
    add_output(index, external_address, "5.0");

    // finalize transaction with min fee of 0.00226 doge on the input total of 12 dogecoin
    char* rawhex = finalize_transaction(index, external_address, "0.00226", "12.0", my_address);
    printf("Finalized transaction hex is %s.", rawhex);
    clear_transaction(index);
}
</code></pre>
<hr />
<h3 id="finalize_transaction_ex"><a class="header" href="#finalize_transaction_ex"><strong>finalize_transaction_ex</strong></a></h3>
<pre><code class="language-c">int finalize_transaction_ex(int txindex, const char* destinationaddress, const char* subtractedfee, const char* total_in_doge, const char* changeaddress, char* out_hex, size_t out_cap);
</code></pre>
<p><code>finalize_transaction_ex</code> one-shots the <em>“close &amp; return change”</em> step while <strong>avoiding a heap allocation</strong>: it finalizes the working transaction at <code>txindex</code>, figures out fees / change exactly as <code>finalize_transaction()</code> does, hex-serialises the result straight into the caller-supplied buffer <code>out_hex</code> (whose capacity in bytes is <code>out_cap</code>), then returns the number of characters written (not counting the terminating <code>'\0'</code>).
If any argument is invalid or the buffer is too small the function returns 0.</p>
<p><em>C usage:</em></p>
<pre><code class="language-c">// build the TX (add_utxo / add_output)

char txhex[TXHEXMAXLEN + 1];          // +1 for the NUL
int n = finalize_transaction_ex(idx,
                                "nbGfXLskPh7eM1iG5zz5EfDkkNTo9TRmde", // destination
                                "0.00226",                            // fee
                                "12.0",                               // total inputs
                                "noxKJyGPugPRN4wqvrwsrtYXuQCk7yQEsy", // change back here
                                txhex,
                                sizeof(txhex));

if (n == 0) {
    // handle error
} else {
    printf("Finalised TX (%d chars):\n%s\n", n, txhex);
}
</code></pre>
<hr />
<h3 id="get_raw_transaction"><a class="header" href="#get_raw_transaction"><strong>get_raw_transaction</strong></a></h3>
<p><code>char* get_raw_transaction(int txindex)</code></p>
<p>This function takes in a working_transaction's index as an integer (txindex) and returns the current working_transaction in raw hexadecimal format.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
    int index = start_transaction();
    char* rawhex = get_raw_transaction(index);
    printf("The transaction hex at index %d is %s.\n", index, rawhex);
    clear_transaction(index);
}
</code></pre>
<hr />
<h3 id="get_raw_transaction_ex"><a class="header" href="#get_raw_transaction_ex"><strong>get_raw_transaction_ex</strong></a></h3>
<pre><code class="language-c">int get_raw_transaction_ex(int   txindex,
                           char* buf,
                           size_t buf_cap);
</code></pre>
<p>The <code>get_raw_transaction_ex</code> function writes the raw hexadecimal representation of the working transaction at index <code>txindex</code> into the caller-supplied buffer <code>buf</code> (of total size <code>buf_cap</code>). On success it returns the number of characters written (not counting the terminating <code>'\0'</code>); if the index is invalid, a pointer is NULL, or the buffer is too small, it returns 0. Unlike <code>get_raw_transaction()</code>, this version avoids allocating a new string on the heap, making it ideal when you already manage your own buffer.</p>
<p><em>C usage:</em></p>
<pre><code class="language-c">char buf[TXHEXMAXLEN + 1];
int len = get_raw_transaction_ex(index, buf, sizeof(buf));
if (len == 0) {
    // handle error
} else {
    printf("Transaction hex: %s\n", buf);
}
</code></pre>
<hr />
<h3 id="clear_transaction"><a class="header" href="#clear_transaction"><strong>clear_transaction</strong></a></h3>
<p><code>void clear_transaction(int txindex)</code></p>
<p>This function takes in a working_transaction's index as an integer (txindex), and removes the transaction at that index from the hash table. All memory dedicated to transaction objects, such as dogecoin_tx_in and dogecoin_tx_out, is freed from within this function.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
    int index = start_transaction();
    clear_transaction(index);
    printf("The transaction hex at index %d is %s.\n", index, get_raw_transaction(index)); // should return (null)
}
</code></pre>
<hr />
<h3 id="sign_raw_transaction"><a class="header" href="#sign_raw_transaction"><strong>sign_raw_transaction</strong></a></h3>
<p><code>int sign_raw_transaction(int inputindex, char* incomingrawtx, char* scripthex, int sighashtype, char* privkey)</code></p>
<p>This function takes in an index denoting which of the current transaction's inputs to sign (inputindex), the raw hexadecimal representation of the transaction to sign (incomingrawtx), the pubkey script in hexadecimal format (scripthex), the signature hash type (sighashtype) and the WIF-encoded private key used to sign the input (privkey). Signature hash type in normal use cases is set to 1 to denote that anyone can pay. In C, the function returns a boolean denoting success, but the actual signed transaction hex is passed back through incomingrawtx. <strong>Important:</strong> <code>sign_raw_transaction</code> must be run within a secp256k1 context, which can be created by calling <code>dogecoin_ecc_start()</code> and <code>dogecoin_ecc_stop()</code> as shown below.</p>
<p><strong>Note:</strong> The <code>incomingrawtx</code> buffer <strong>must</strong> be the buffer returned by <code>get_raw_transaction()</code>, otherwise the signed hex may overflow.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
    char* prev_output_txid_2 = "b4455e7b7b7acb51fb6feba7a2702c42a5100f61f61abafa31851ed6ae076074"; // worth 2 dogecoin
    char* prev_output_txid_10 = "42113bdc65fc2943cf0359ea1a24ced0b6b0b5290db4c63a3329c6601c4616e2"; // worth 10 dogecoin
    int prev_output_n_2 = 1;
    int prev_output_n_10 = 1;
    char* external_address = "nbGfXLskPh7eM1iG5zz5EfDkkNTo9TRmde";
    char* my_address = "noxKJyGPugPRN4wqvrwsrtYXuQCk7yQEsy";
    char* my_script_pubkey = "76a914d8c43e6f68ca4ea1e9b93da2d1e3a95118fa4a7c88ac";
    char* my_privkey = "ci5prbqz7jXyFPVWKkHhPq4a9N8Dag3TpeRfuqqC2Nfr7gSqx1fy";

    int index = start_transaction();
    add_utxo(index, prev_output_txid_2, prev_output_n_2);
    add_utxo(index, prev_output_txid_10, prev_output_n_10);
    add_output(index, external_address, "5.0");
    finalize_transaction(index, external_address, "0.00226", "12.0", my_address);

    //sign both inputs of the current finalized transaction
    dogecoin_ecc_start();
    char* rawhex = get_raw_transaction(index);
    sign_raw_transaction(0, rawhex, my_script_pubkey, 1, my_privkey);
    sign_raw_transaction(1, rawhex, my_script_pubkey, 1, my_privkey);
    dogecoin_ecc_stop();
    printf("The final signed transaction hex is: %s\n", rawhex);
    clear_transaction(index);
}
</code></pre>
<hr />
<h3 id="sign_raw_transaction_ex"><a class="header" href="#sign_raw_transaction_ex"><strong>sign_raw_transaction_ex</strong></a></h3>
<pre><code class="language-c">int sign_raw_transaction_ex(int           inputindex,
                            const char*   incomingrawtx,
                            char*         signedrawtx,
                            size_t*       signed_size,
                            const char*   scripthex,
                            int           sighashtype,
                            const char*   privkey);
</code></pre>
<p>The <code>sign_raw_transaction_ex</code> function offers a two-step interface for signing a single input of a raw transaction. In <strong>query mode</strong>, you pass <code>signedrawtx == NULL</code>; the function writes the required buffer size (including the null terminator) into <code>*signed_size</code> and returns 1. In <strong>write mode</strong>, you allocate at least that many bytes, pass the buffer in <code>signedrawtx</code> (with <code>*signed_size</code> set to its capacity), and call it again. On success it writes the signed transaction hex (plus <code>'\0'</code>) into your buffer and returns 1; on failure it returns 0. This pattern avoids extra heap allocations when you want to supply your own output buffer.</p>
<p><em>C usage:</em></p>
<pre><code class="language-c">// Stage 1: query required size
size_t need = 0;
if (!sign_raw_transaction_ex(0, rawhex, NULL, &amp;need, scripthex, 1, wif)) {
    // error
}

// Stage 2: allocate and sign
char *out = malloc(need);
if (!out) { /* OOM */ }
if (!sign_raw_transaction_ex(0, rawhex, out, &amp;need, scripthex, 1, wif)) {
    // error
}
printf("Signed transaction: %s\n", out);
free(out);
</code></pre>
<hr />
<h3 id="sign_transaction"><a class="header" href="#sign_transaction"><strong>sign_transaction</strong></a></h3>
<p><code>int sign_transaction(int txindex, char* script_pubkey, char* privkey)</code></p>
<p>This function takes in a working transaction structure's index as an integer (txindex), the pubkey in script hex form (script_pubkey) and the WIF-encoded private key (privkey). Each input is then signed using the specified private key, and the final signed transaction is saved to the hash table, which can be retrieved using <code>get_raw_transaction()</code>. The return value of <code>sign_transaction()</code> is a boolean denoting whether the signing was successful, but the output from <code>get_raw_transaction()</code> is a fully signed transaction that--if all information is valid--can be broadcast to miners and incorporated into the blockchain. <strong>Important:</strong> <code>sign_transaction</code> must also be run within a secp256k1 context, which can be created by calling <code>dogecoin_ecc_start()</code> and <code>dogecoin_ecc_stop()</code> as shown below.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
    char* prev_output_txid_2 = "b4455e7b7b7acb51fb6feba7a2702c42a5100f61f61abafa31851ed6ae076074"; // worth 2 dogecoin
    char* prev_output_txid_10 = "42113bdc65fc2943cf0359ea1a24ced0b6b0b5290db4c63a3329c6601c4616e2"; // worth 10 dogecoin
    int prev_output_n_2 = 1;
    int prev_output_n_10 = 1;
    char* external_address = "nbGfXLskPh7eM1iG5zz5EfDkkNTo9TRmde";
    char* my_address = "noxKJyGPugPRN4wqvrwsrtYXuQCk7yQEsy";
    char* my_script_pubkey = "76a914d8c43e6f68ca4ea1e9b93da2d1e3a95118fa4a7c88ac";
    char* my_privkey = "ci5prbqz7jXyFPVWKkHhPq4a9N8Dag3TpeRfuqqC2Nfr7gSqx1fy";

    int index = start_transaction();
    add_utxo(index, prev_output_txid_2, prev_output_n_2);
    add_utxo(index, prev_output_txid_10, prev_output_n_10);
    add_output(index, external_address, "5.0");
    finalize_transaction(index, external_address, "0.00226", "12.0", my_address);

    //sign both inputs of the current finalized transaction
    dogecoin_ecc_start();
    if (!sign_transaction(index, my_script_pubkey, my_privkey)) {
        // error handling here
    }
    dogecoin_ecc_stop();
    printf("The final signed transaction hex is: %s\n", get_raw_transaction(index));
    clear_transaction(index);
}
</code></pre>
<hr />
<h3 id="store_raw_transaction"><a class="header" href="#store_raw_transaction"><strong>store_raw_transaction</strong></a></h3>
<p><code>int store_raw_transaction(char* incomingrawtx)</code></p>
<p>This function is equivalent to <code>save_raw_transaction</code> but takes the next available index in the hash table to save the provided transaction hex (incomingrawtx), rather than allowing the user to specify which index. It then returns this automatically chosen index as an integer.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
    char* hex_to_store = "0100000001746007aed61e8531faba1af6610f10a5422c70a2a7eb6ffb51cb7a7b7b5e45b40100000000ffffffff0000000000";
    int index = store_raw_transaction(hex_to_store);
    printf("The transaction hex at index %d is %s.\n", index, get_raw_transaction(index));
    clear_transaction(index);
}
</code></pre>
<hr />
<h3 id="sign_indexed_raw_transaction_ex"><a class="header" href="#sign_indexed_raw_transaction_ex"><strong>sign_indexed_raw_transaction_ex</strong></a></h3>
<pre><code class="language-c">int sign_indexed_raw_transaction_ex(int txindex,
                                    int inputindex,
                                    const char* scripthex,
                                    int sighashtype,
                                    const char* privkey,
                                    char* buf,
                                    size_t buf_cap);
</code></pre>
<p>Signs <strong>one</strong> specific input (<code>inputindex</code>) of the working transaction stored at <code>txindex</code>, writes the fully-updated raw-hex straight into the caller-supplied buffer <code>buf</code> (capacity <code>buf_cap</code>) and returns the number of hex characters written (not counting the terminating <code>'\0'</code>).
If the buffer is too small or any argument is invalid the function returns 0.</p>
<pre><code class="language-c">char signedhex[TXHEXMAXLEN + 1];
int n = sign_indexed_raw_transaction_ex(idx,        /* tx we're editing   */
                                        0,          /* which vin to sign  */
                                        scripthex,  /* utxo's scriptPubKey*/
                                        1,          /* SIGHASH_ALL        */
                                        wif,        /* signing key        */
                                        signedhex,
                                        sizeof signedhex);
if (n == 0) { /* error */ }
</code></pre>
<h3 id="sign_transaction_ex"><a class="header" href="#sign_transaction_ex"><strong>sign_transaction_ex</strong></a></h3>
<pre><code class="language-c">int sign_transaction_ex(int txindex,
                         const char* script_pubkey,
                         const char* privkey,
                         char* buf,
                         size_t buf_cap);
</code></pre>
<p>High-level helper that iterates over <strong>all</strong> inputs of the working transaction at <code>txindex</code>, signing each one with the same <code>script_pubkey</code> / <code>privkey</code> pair, then emits the completely-signed transaction hex into <code>buf</code>.
Return-value semantics are identical to the previous function.</p>
<pre><code class="language-c">char finalhex[TXHEXMAXLEN + 1];
if (!sign_transaction_ex(idx, scripthex, wif, finalhex, sizeof finalhex)) {
    /* signing failed */
}
printf("fully-signed tx:\n%s\n", finalhex);
</code></pre>
<h3 id="sign_transaction_w_privkey_ex"><a class="header" href="#sign_transaction_w_privkey_ex"><strong>sign_transaction_w_privkey_ex</strong></a></h3>
<pre><code class="language-c">int sign_transaction_w_privkey_ex(int txindex,
                                  const char* privkey,
                                  char* buf,
                                  size_t buf_cap);
</code></pre>
<p>Single-key convenience wrapper: derives the P2PKH <code>scriptPubKey</code> from <code>privkey</code>, signs <strong>every</strong> input of the transaction at <code>txindex</code>, and streams the result into <code>buf</code>.
Ideal for the common <em>all inputs belong to the same wallet</em> scenario.</p>
<pre><code class="language-c">char txhex[TXHEXMAXLEN + 1];
if (!sign_transaction_w_privkey_ex(idx, wif, txhex, sizeof txhex)) {
    /* error */
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="dogecoin-transaction-overview"><a class="header" href="#dogecoin-transaction-overview">Dogecoin Transaction Overview</a></h3>
<p>The <code>dogecoin_tx</code> structure describes a dogecoin transaction in reply to getdata. When a bloom filter is applied tx objects are sent automatically for matching transactions following the merkleblock. It is composed of the following fields:</p>
<div class="table-wrapper"><table><thead><tr><th>Field Size</th><th>Description</th><th>Data type</th><th>Comments</th></tr></thead><tbody>
<tr><td>4</td><td>version</td><td>uint32_t</td><td>Transaction data format version</td></tr>
<tr><td>1+</td><td>tx_in count</td><td>var_int</td><td>Number of Transaction inputs (never zero)</td></tr>
<tr><td>41+</td><td>tx_in</td><td>tx_in[]</td><td>A list of 1 or more transaction inputs or sources for coins</td></tr>
<tr><td>1+</td><td>tx_out count</td><td>var_int</td><td>Number of Transaction outputs</td></tr>
<tr><td>9+</td><td>tx_out</td><td>tx_out[]</td><td>A list of 1 or more transaction outputs or destinations for coins</td></tr>
<tr><td>4</td><td>lock_time</td><td>uint32_t</td><td>The block number or timestamp at which this transaction is unlocked: 0 == not locked, &lt; 500000000 == Block number at which this transaction is unlocked, &gt;= 500000000 == UNIX timestamp at which this transaction is unlocked. If all TxIn have final (0xffffffff) sequence numbers then lock_time is irrelevant. Otherwise, the transaction may not be added to a block until after lock_time (see NLockTime).</td></tr>
</tbody></table>
</div>
<p><code>include/dogecoin/tx.h</code>:</p>
<pre><code>typedef struct dogecoin_tx_ {
    int32_t version;
    vector_t* vin;
    vector_t* vout;
    uint32_t locktime;
} dogecoin_tx;
</code></pre>
<p>Every transaction is composed of inputs and outputs, which specify where the funds came from and where they will go. These are represented by the <code>dogecoin_tx_in</code> and <code>dogecoin_tx_out</code> structs below.</p>
<h3 id="dogecoin-transaction-input"><a class="header" href="#dogecoin-transaction-input">Dogecoin Transaction Input</a></h3>
<p>The <code>dogecoin_tx_in</code> structure consists of the following fields:</p>
<div class="table-wrapper"><table><thead><tr><th>Field Size</th><th>Description</th><th>Data type</th><th>Comments</th></tr></thead><tbody>
<tr><td>36</td><td>previous_output</td><td>outpoint</td><td>The previous output transaction reference, as an Outpoint structure</td></tr>
<tr><td>1+</td><td>script_length</td><td>var_int</td><td>The length of the signature script</td></tr>
<tr><td>?</td><td>signature_script</td><td>uchar[]</td><td>Computational Script for confirming transaction authorization</td></tr>
<tr><td>4</td><td>sequence</td><td>uint32_t</td><td>Transaction version as defined by the sender. Intended for "replacement" of transactions when information is updated before inclusion into a block.</td></tr>
</tbody></table>
</div>
<p><code>include/dogecoin/tx.h</code>:</p>
<pre><code>typedef struct dogecoin_tx_in_ {
    dogecoin_tx_outpoint prevout;
    cstring* script_sig;
    uint32_t sequence;
} dogecoin_tx_in;
</code></pre>
<p>The <code>dogecoin_tx_outpoint</code> structure represented above as <code>prevout</code> consists of the following fields:</p>
<div class="table-wrapper"><table><thead><tr><th>Field Size</th><th>Description</th><th>Data type</th><th>Comments</th></tr></thead><tbody>
<tr><td>32</td><td>hash</td><td>char[32]</td><td>The hash of the referenced transaction</td></tr>
<tr><td>4</td><td>index</td><td>uint32_t</td><td>The index of the specific output in the transaction. The first output is 0, etc.</td></tr>
</tbody></table>
</div>
<p><code>include/dogecoin/tx.h</code>:</p>
<pre><code>typedef struct dogecoin_tx_outpoint_ {
    uint256_t hash;
    uint32_t n;
} dogecoin_tx_outpoint;
</code></pre>
<h3 id="dogecoin-transaction-output"><a class="header" href="#dogecoin-transaction-output">Dogecoin Transaction Output</a></h3>
<p>The <code>dogecoin_tx_out</code> structure consists of the following fields:</p>
<div class="table-wrapper"><table><thead><tr><th>Field Size</th><th>Description</th><th>Data type</th><th>Comments</th></tr></thead><tbody>
<tr><td>8</td><td>value</td><td>int64_t</td><td>Transaction value</td></tr>
<tr><td>1+</td><td>pk_script length</td><td>var_int</td><td>Length of the pk_script</td></tr>
<tr><td>?</td><td>pk_script</td><td>uchar[]</td><td>Usually contains the public key as a dogecoin script setting up conditions to claim this output.</td></tr>
</tbody></table>
</div>
<p><code>include/dogecoin/tx.h</code>:</p>
<pre><code>typedef struct dogecoin_tx_out_ {
    int64_t value;
    cstring* script_pubkey;
} dogecoin_tx_out;
</code></pre>
<h4 id="standard-transaction-to-dogecoin-address-pay-to-pubkey-hash"><a class="header" href="#standard-transaction-to-dogecoin-address-pay-to-pubkey-hash">Standard Transaction to Dogecoin Address (pay-to-pubkey-hash)</a></h4>
<p>The <code>dogecoin_script</code> structure consists of a series of pieces of information and operations related to the value of the transaction. When notating scripts, data to be pushed to the stack is generally enclosed in angle brackets and data push commands are omitted. Non-bracketed words are opcodes. These examples include the "OP_" prefix, but it is permissible to omit it. Thus "<pubkey1> <pubkey2> OP_2 OP_CHECKMULTISIG" may be abbreviated to "<pubkey1> <pubkey2> 2 CHECKMULTISIG". Note that there is a small number of standard script forms that are relayed from node to node; non-standard scripts are accepted if they are in a block, but nodes will not relay them.</p>
<pre><code>scriptPubKey: OP_DUP OP_HASH160 &lt;pubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG
scriptSig: &lt;sig&gt; &lt;pubKey&gt;
</code></pre>
<p>To demonstrate how scripts look on the wire, here is a raw scriptPubKey:</p>
<pre><code>  76       A9             14
OP_DUP OP_HASH160    Bytes to push

89 AB CD EF AB BA AB BA AB BA AB BA AB BA AB BA AB BA AB BA   88         AC
                      Data to push                     OP_EQUALVERIFY OP_CHECKSIG
</code></pre>
<h5 id="note-scriptsig-is-in-the-input-of-the-spending-transaction-and-scriptpubkey-is-in-the-output-of-the-previously-unspent-ie-available-transaction"><a class="header" href="#note-scriptsig-is-in-the-input-of-the-spending-transaction-and-scriptpubkey-is-in-the-output-of-the-previously-unspent-ie-available-transaction"><strong>Note: scriptSig is in the input of the spending transaction and scriptPubKey is in the output of the previously unspent i.e. "available" transaction.</strong></a></h5>
<p>Here is how each word is processed:</p>
<div class="table-wrapper"><table><thead><tr><th>Stack</th><th>Script</th><th>Description</th></tr></thead><tbody>
<tr><td>Empty</td><td><code>&lt;sig&gt; &lt;pubKey&gt;</code> OP_DUP OP_HASH160 <code>&lt;pubKeyHash&gt;</code> OP_EQUALVERIFY OP_CHECKSIG</td><td>scriptSig and scriptPubKey are combined.</td></tr>
<tr><td><code>&lt;sig&gt; &lt;pubKey&gt;</code></td><td>OP_DUP OP_HASH160 <code>&lt;pubKeyHash&gt;</code> OP_EQUALVERIFY OP_CHECKSIG</td><td>Constants are added to the stack.</td></tr>
<tr><td><code>&lt;sig&gt; &lt;pubKey&gt; &lt;pubKey&gt;</code></td><td>OP_HASH160 <code>&lt;pubKeyHash&gt;</code> OP_EQUALVERIFY OP_CHECKSIG</td><td>Top stack item is duplicated.</td></tr>
<tr><td><code>&lt;sig&gt; &lt;pubKey&gt; &lt;pubHashA&gt;</code></td><td><code>&lt;pubKeyHash&gt;</code> OP_EQUALVERIFY OP_CHECKSIG</td><td>Top stack item is hashed.</td></tr>
<tr><td><code>&lt;sig&gt; &lt;pubKey&gt; &lt;pubHashA&gt; &lt;pubKeyHash&gt;</code></td><td>OP_EQUALVERIFY OP_CHECKSIG</td><td>Constant added.</td></tr>
<tr><td><code>&lt;sig&gt; &lt;pubKey&gt;</code></td><td>OP_CHECKSIG</td><td>Equality is checked between the top two stack items.</td></tr>
<tr><td>true</td><td>Empty</td><td>Signature is checked for top two stack items.</td></tr>
</tbody></table>
</div>
<p><code>include/dogecoin/tx.h</code>:</p>
<pre><code>typedef struct dogecoin_script_ {
    int* data;
    size_t limit;   // Total size of the vector
    size_t current; //Number of vectors in it at present
} dogecoin_script;
</code></pre>
<h5 id="-the-examples-above-were-derived-from-httpsenbitcoinit"><a class="header" href="#-the-examples-above-were-derived-from-httpsenbitcoinit">* <em>The examples above were derived from https://en.bitcoin.it</em></a></h5>
<div style="break-before: page; page-break-before: always;"></div><h3 id="yubikey-storage-of-encrypted-keys"><a class="header" href="#yubikey-storage-of-encrypted-keys">YubiKey Storage of Encrypted Keys</a></h3>
<p>The YubiKey is a hardware security key that provides strong two-factor authentication and secure cryptographic operations. By integrating the YubiKey with libdogecoin, users can enhance the security of their wallets and transactions. While the integration is tested with YubiKey 5 NFC, it also works with other YubiKey models that support PIV (Personal Identity Verification).</p>
<p>YubiKey supports numerous cryptographic operations; for libdogecoin, we are primarily interested in the PIV application. The PIV application provides a secure way to store private keys. The YubiKey acts as secure key storage, protecting the private keys from unauthorized access.</p>
<p>We have integrated the YubiKey with the <code>seal</code> module, specifically for encrypted key storage. The <code>seal</code> module is responsible for encrypting and decrypting the private keys stored in the YubiKey. By using the YubiKey, users can securely store and retrieve their private keys during wallet operations.</p>
<p>The process involves multi-factor authentication (PIN and YubiKey) to unlock the encrypted keys, followed by the decryption of BIP39 mnemonics. The seed, master key, or mnemonic is first encrypted with software and then stored on the YubiKey. During the storage process, the user enters a management password, and to retrieve the key, the user enters the YubiKey PIN.</p>
<p>Its recommeded that the user download the YubiKey Manager to manage the YubiKey. The YubiKey Manager is a graphical user interface that allows users to change the PIN, management key, and other settings. The YubiKey Manager is available for Windows, macOS, and Linux from the <a href="https://www.yubico.com/support/download/yubikey-manager/">Yubico website</a>.</p>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<ul>
<li><code>libykpiv</code> - The YubiKey C library for interacting with the YubiKey.</li>
<li><code>libykpiv-dev</code> - The development headers for the YubiKey C library.</li>
<li><code>pcscd</code> - The PC/SC smart card daemon for managing smart card readers.</li>
<li><code>libpcsclite-dev</code> - The development headers for the PC/SC smart card library.</li>
</ul>
<h3 id="installation"><a class="header" href="#installation">Installation</a></h3>
<h4 id="linux"><a class="header" href="#linux">Linux</a></h4>
<pre><code class="language-sh">sudo apt-get update
sudo apt-get install libykpiv libykpiv-dev pcscd libpcsclite-dev
</code></pre>
<h3 id="example-c-code"><a class="header" href="#example-c-code">Example C Code</a></h3>
<pre><code class="language-c">// Encrypt a BIP32 seed with software and store it on YubiKey
u_assert_true(dogecoin_encrypt_seed_with_sw_to_yubikey(seed, sizeof(SEED), TEST_FILE, true, test_password));
debug_print("Seed to YubiKey: %s\n", utils_uint8_to_hex(seed, sizeof(SEED)));
debug_print("Encrypted seed: %s\n", utils_uint8_to_hex(file, filesize));

// Decrypt a BIP32 seed with software after retrieving it from YubiKey
uint8_t decrypted_seed[4096] = {0};
u_assert_true(dogecoin_decrypt_seed_with_sw_from_yubikey(decrypted_seed, TEST_FILE, test_password));
debug_print("Decrypted seed: %s\n", utils_uint8_to_hex(decrypted_seed, decrypted_size));
u_assert_true(memcmp(seed, decrypted_seed, sizeof(SEED)) == 0);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="community-projects"><a class="header" href="#community-projects">Community Projects</a></h1>
<ul>
<li><a href="https://github.com/mydoge-com/dogecoin-js">dogecoin-js</a></li>
<li><a href="https://github.com/alamshafil/dart-libdogecoin">dart-libdogecoin</a></li>
<li><a href="https://github.com/UsaRandom/Lib.Dogecoin">Lib.Dogecoin</a></li>
<li><a href="https://github.com/UsaRandom/RadioDoge-FirmwareInstaller">RadioDoge-FirmwareInstaller</a></li>
<li><a href="https://github.com/chromatic/Alien-Libdogecoin">Alien-Libdogecoin</a></li>
<li><a href="https://github.com/chromatic/Finance-libdogecoin">Finance-libdogecoin</a></li>
</ul>
<h1 id="foundation-projects"><a class="header" href="#foundation-projects">Foundation Projects</a></h1>
<ul>
<li><a href="https://radio.dogecoin.org">radiodoge</a></li>
<li><a href="https://github.com/dogeorg/python-libdogecoin">python-libdogecoin</a></li>
<li><a href="https://github.com/qlpqlp/libdogecoin-php">libdogecoin-php</a></li>
<li><a href="https://github.com/qlpqlp/DogeBraille">Doge Braille</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-stages"><a class="header" href="#project-stages">Project stages</a></h1>
<p>We understand that there's a steep lerning curve for most of the folk working
on this project, and that's OK. This is an inflection point for the Dogecoin
community: moving from a tiny dev team to a wider #dogeDevArmy is great for
derisking the bus-factor aspect of Dogecoin. The process of creating libdogecoin
is an important step toward a broader and more sustainable community of devs.</p>
<p>With that in mind we're suggesting a staged approach to this project. Starting
with the basics and delivering working vertical slices of functionality
as a useful C library with a handful of higher level language wrappers early,
should force us to solve fundamental concerns such as language wrappers, testing
and other issues before getting too far down a rabbit hole.</p>
<p><img src="/diagrams/libdogecoin-stage1.png" alt="Stage 1 Diagram" /></p>
<p>Stage one lets us learn and understand the lowest level building blocks of Dogecoin
as we build each slice of functionality and deliver incremental releases with full
tests, doc and perhaps even commandline utilities that exercise them. We expect
that this approach will gain momentum after the first and second 'slice' as we face
and solve the problems of library design, building effective language wrappers etc.</p>
<p><img src="/diagrams/libdogecoin-stage2.png" alt="Stage 2 Diagram" /></p>
<p>Stage two makes use of the low level building blocks we've delivered by combining
them into higher level components that are needed to build wallets and nodes. This
is where we deliver the parts needed for other members of the community to cobble
together operational doge projects.</p>
<p><img src="/diagrams/libdogecoin-stage3.png" alt="Stage 3a Diagram" /></p>
<p>Stage three A takes what we've built and uses it to create a new Dogecoin Node
service (in C) capable of joining the network and participating in the blockchain.
The plan is to make this new DogeNode available for Windows, Linux, MacOS etc. in
a simple-to-setup manner that will encourage new users to support the network.</p>
<p>This DogeNode should be far simpler to maintain, being abstracted from the many
'and the kitchen sink' additions that encumber the Dogecoin Core daemon.</p>
<p><img src="/diagrams/libdogecoin-stage3b.png" alt="Stage 3b Diagram" /></p>
<p>At the same time, GigaWallet which is being built around the Dogecoin Core APIs
can be easily ported to libdogecoin so it can operate directly on L1 to transact
dogecoin. This will be the first major project using libdogecoin via a language
binding, and prove the ability for libdogecoin to enable greater flexibility in
how the community can get involved in development.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="release-process"><a class="header" href="#release-process">Release Process</a></h1>
<ol>
<li>Open PR to main that
<ol>
<li>adds release notes to <code>doc/changelog.md</code> (see below) and</li>
<li>if this is <strong>not</strong> a patch release, updates <code>_PKG_VERSION_{MAJOR,MINOR}</code> and <code>_LIB_VERSIONS_*</code> in <code>configure.ac</code></li>
</ol>
</li>
<li>After the PR is merged,
<ul>
<li>if this is <strong>not</strong> a patch release, create a release branch with name <code>MAJOR.MINOR</code>.
Make sure that the branch contains the right commits.
Create commit on the release branch that sets <code>_PKG_VERSION_IS_RELEASE</code> in <code>configure.ac</code> to <code>true</code>.</li>
<li>if this <strong>is</strong> a patch release, open a pull request with the bugfixes to the <code>MAJOR.MINOR</code> branch.
Also include the release note commit bump <code>_PKG_VERSION_PATCH</code> and <code>_LIB_VERSIONS_*</code> in <code>configure.ac</code>.</li>
</ul>
</li>
<li>Tag the commit with <code>git tag -s vMAJOR.MINOR.PATCH</code>.</li>
<li>Push branch and tag with <code>git push origin --tags</code>.</li>
<li>Create a new GitHub release with a link to the corresponding entry in <code>doc/changelog.md</code>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<h2 id="released"><a class="header" href="#released">[Released]</a></h2>
<h2 id="014---2025-04-10"><a class="header" href="#014---2025-04-10">[0.1.4] - 2025-04-10</a></h2>
<h2 id="whats-changed"><a class="header" href="#whats-changed">What's Changed</a></h2>
<ul>
<li>merge v0.1.3 into main by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/204</li>
<li>added 'tbs' library link by @UsaRandom in https://github.com/dogecoinfoundation/libdogecoin/pull/205</li>
<li>net: added disconnected state for shutdown by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/207</li>
<li>src: added intel assembly for sha algs by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/208</li>
<li>ci: comment out arm64-macos due to gh billing by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/209</li>
<li>build: require secp256k1 build first in Makefile by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/211</li>
<li>ci: pin macos version to 12 instead of latest by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/214</li>
<li>net: added http server by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/212</li>
<li>blockchain: moved chainwork to blockindex by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/213</li>
<li>crypto: adds chacha20 and fast_random_context by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/210</li>
<li>fix DragonFlyBSD 6.4-RELEASE support by @movepointsolutions in https://github.com/dogecoinfoundation/libdogecoin/pull/182</li>
<li>Make getDerivedHDAddress return address, not key by @chromatic in https://github.com/dogecoinfoundation/libdogecoin/pull/218</li>
<li>spvnode: move http callback function to it's own respective file by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/220</li>
<li>fixate 0.1.4-dogebox-pre by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/221</li>
<li>[feat] Add Key Management Enclaves with YubiKey and NanoPC-T6 Support by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/223</li>
<li>config: add -levent_core to AC_CHECK_LIB for event_extra by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/225</li>
<li>ci: added 'tags' to 'on:' for sign actions by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/227</li>
<li>ci: updated runner to macos-13 by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/229</li>
<li>optee, openenclave: added custom key path parameter by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/238</li>
<li>depends: disable libunistring for mingw32 by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/228</li>
<li>src: updated reference and error handling in rest by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/226</li>
<li>such: updated usage for public child keys by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/230</li>
<li>chainparams: added backup dns seed by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/239</li>
<li>add _t suffix to uint256, uint160 and vector types by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/240</li>
<li>sha2: added armv8 and armv8.2 crypto by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/231</li>
<li>rest: added getTimestamp endpoint by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/234</li>
<li>rest: added getLastBlockInfo endpoint  by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/235</li>
<li>rest: added utxo confirmations by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/236</li>
<li>validation: check auxpow PoW before other checks by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/237</li>
<li>ci: updated Windows signing certs and root by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/241</li>
<li>optee: enable TRNG, add LIBDIR overrides, and switch fortify flag by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/242</li>
<li>sha2: moved armv8 and armv82 guards by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/243</li>
<li>ci: added windows native release and no tpm builds by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/244</li>
<li>wallet: restore logic check by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/245</li>
<li>cmake: restore flag settings by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/246</li>
<li>docs: update changelog.md by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/247</li>
<li>fixate 0.1.4 by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/248</li>
<li>fixate gitian descriptors by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/249</li>
<li>docs: re-update changelog.md by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/250</li>
<li>depends: make yubikey depends selectable by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/251</li>
<li>docs: finalize changelog.md by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/252</li>
</ul>
<h2 id="new-contributors"><a class="header" href="#new-contributors">New Contributors</a></h2>
<ul>
<li>@UsaRandom made their first contribution in https://github.com/dogecoinfoundation/libdogecoin/pull/205</li>
<li>@movepointsolutions made their first contribution in https://github.com/dogecoinfoundation/libdogecoin/pull/182</li>
</ul>
<p><strong>Full Changelog</strong>: https://github.com/dogecoinfoundation/libdogecoin/compare/v0.1.3...v0.1.4</p>
<h2 id="013---2024-02-07"><a class="header" href="#013---2024-02-07">[0.1.3] - 2024-02-07</a></h2>
<ul>
<li>logdb: adds files and tests for spv node wallet database by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/110.</li>
<li>depends: add build support for arm64-apple-darwin by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/111.</li>
<li>added libdogecoin-config.h to install by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/112.</li>
<li>ci/codeql: bump node.js actions from 12 to 16 by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/113.</li>
<li>config: added config flag for unistring by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/115.</li>
<li>spv/wallet: add files and tests by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/117.</li>
<li>cmake: added use_unistring symbol by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/118.</li>
<li>additional secp256k1 source exclusions by @Eshnek in https://github.com/dogecoinfoundation/libdogecoin/pull/119.</li>
<li>spvnode/wallet: support multiple watch addresses per init by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/120.</li>
<li>qa: omit p2wpkh section from test_wallet by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/121.</li>
<li>build: enable building shared lib via cmake by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/122.</li>
<li>fix minor typo in readme by @themagic314 in https://github.com/dogecoinfoundation/libdogecoin/pull/123.</li>
<li>ci: update mac osx sdk checksum by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/124.</li>
<li>scrypt: add files and test by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/125.</li>
<li>bug-fix: python wrapper missing unistring by @joijuke in https://github.com/dogecoinfoundation/libdogecoin/pull/126.</li>
<li>python wrapper better setup practice by @joijuke in https://github.com/dogecoinfoundation/libdogecoin/pull/127.</li>
<li>wallet: add get vout and amount functions and expose koinu str funcs by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/128.</li>
<li>restruct python wrapper by @joijuke in https://github.com/dogecoinfoundation/libdogecoin/pull/129.</li>
<li>map: add files and use in deserialize_dogecoin_auxpow_block by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/130.</li>
<li>wallet: fix rehydration of waddr_rbtree and route wtx to proper vector by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/131.</li>
<li>spvnode: added wallet files by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/132.</li>
<li>wallet: make dogecoin_wallet_scrape_utxos account for edge case by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/133.</li>
<li>map: remove extraneous swap_bytes function from map.c by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/134.</li>
<li>qa/spv: shorten block duration on ibd and switch to testnet for spv_test by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/135.</li>
<li>wrappers: remove wrappers dir, decouple from ci/codeql by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/136.</li>
<li>spvnode: added headers files by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/137.</li>
<li>wallet: prevent duplicate utxos from being added to unspent vector by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/138.</li>
<li>depends: add support for android by @alamshafil in https://github.com/dogecoinfoundation/libdogecoin/pull/140.</li>
<li>wallet: fix dogecoin_wallet_unregister_watch_address_with_node by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/142.</li>
<li>0.1.3 dev expose tools by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/143.</li>
<li>validation: adds block and header checks by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/144.</li>
<li>lib: expose p2pkh utility functions by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/145.</li>
<li>dogecoin_tx_out function in header by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/147.</li>
<li>Added bip and private key utilities by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/148.</li>
<li>address: adds getHDNodeAndExtKeyByPath, getHDNodePrivateKeyWIFByPath by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/151.</li>
<li>TPM2 crypto for mnemonics, seeds and keys on windows by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/153.</li>
<li>Improve HD address derivation by @chromatic in https://github.com/dogecoinfoundation/libdogecoin/pull/154.</li>
<li>lib: added key string constants, chainparams and bip32/44 wrappers by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/158.</li>
<li>0.1.3 dev openenclave by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/159.</li>
<li>cli: addressed compiler warnings in such and spvnode by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/160.</li>
<li>global updates to constants by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/162.</li>
<li>software encrypt/decrypt with cli tools by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/163.</li>
<li>validation: updated scrypt and pow by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/164.</li>
<li>seal: added test_passwd to tpm functions by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/165.</li>
<li>seal: added dogecoin_free and dogecoin_mem_zero of passwords by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/166.</li>
<li>spvnode: updated usage by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/167.</li>
<li>docs: updated tools.md for spvnode by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/168.</li>
<li>utils: added getpass by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/169.</li>
<li>seal: added encrypted store directory by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/170.</li>
<li>vector: updated memory allocation in deserialize by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/171.</li>
<li>validation: added scrypt-sse2 by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/172.</li>
<li>block: added parent merkle check for auxpow by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/173.</li>
<li>hash: added dogecoin_hashwriter_free by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/174.</li>
<li>such: fix mantissa during tx edit by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/175.</li>
<li>ci/ql: added enable-test-passwd option by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/176.</li>
<li>tx: emulate tx_in witness_stack vector in tx deser by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/177.</li>
<li>wallet: free waddrs in dogecoin_wallet_init by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/178.</li>
<li>headersdb_file: updated dogecoin_headers_db_connect_hdr to reorg by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/179.</li>
<li>wallet: redesign utxo and radio doge functions by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/180.</li>
<li>net: updated check to connect nodes by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/183.</li>
<li>ci: added sign jobs for windows and macos by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/184.</li>
<li>wallet: added prompt to dogecoin_wallet_load by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/185.</li>
<li>chainparams: update chain_from_b58_prefix to detect testnet and regtest by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/187.</li>
<li>wallet: clear memory leaks from radio doge functions by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/188.</li>
<li>spv: removed reject on invalid block by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/189.</li>
<li>headersdb_file: updated reorg to find common ancestor with memcmp by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/190.</li>
<li>ci: added tag check to sign actions by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/191.</li>
<li>ci: added test for aarch64-android by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/192.</li>
<li>bip39: added fclose to error conditions by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/193.</li>
<li>spv: optimize initial block download by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/194.</li>
<li>ci: reduced uploads for signed builds by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/195.</li>
<li>tool: updated pubkey_from_privatekey param by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/196.</li>
<li>gitian: bump build system to focal from bionic by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/197.</li>
<li>cmake: added build type for msvc by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/198.</li>
<li>trivial: add copyright script and update copyrights by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/199.</li>
<li>doc: update changelog.md authored by @edtubbs and committed by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/201.</li>
<li>ci: bump to actions/cache@v4 for android by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/202.</li>
<li>ci: config arm64-apple-darwin runner by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/203.</li>
<li>fixate v0.1.3 by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/200.</li>
</ul>
<h2 id="new-contributors-1"><a class="header" href="#new-contributors-1">New Contributors</a></h2>
<ul>
<li>@alamshafil made their first contribution in https://github.com/dogecoinfoundation/libdogecoin/pull/140</li>
<li>@Eshnek made their first contribution in https://github.com/dogecoinfoundation/libdogecoin/pull/119</li>
<li>@joijuke made their first contribution in https://github.com/dogecoinfoundation/libdogecoin/pull/126</li>
<li>@chromatic made their first contribution in https://github.com/dogecoinfoundation/libdogecoin/pull/154</li>
</ul>
<p><strong>Full Changelog</strong>: https://github.com/dogecoinfoundation/libdogecoin/compare/v0.1.2...v0.1.3</p>
<h2 id="012---2023-03-22"><a class="header" href="#012---2023-03-22">[0.1.2] - 2023-03-22</a></h2>
<h2 id="whats-changed-1"><a class="header" href="#whats-changed-1">What's Changed</a></h2>
<ul>
<li>doc: update transaction signing definitions by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/82</li>
<li>build: fix up cmake on linux by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/90</li>
<li>libdogecoin: added wrapper for bip39 by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/91</li>
<li>ci: bump i686-pc-linux-gnu from bionic to focal by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/95</li>
<li>build: add msvs support with cmake by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/93</li>
<li>docs: added bip39 seedphrases and libunistring by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/96</li>
<li>0.1.2 dev QR support by @michilumin in https://github.com/dogecoinfoundation/libdogecoin/pull/94</li>
<li>utils: add dogecoin_network_enabled function by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/87</li>
<li>utils: fix missing libdogecoin-config header by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/97</li>
<li>added jpeg qr functionality using a modified version of jpec by @michilumin in https://github.com/dogecoinfoundation/libdogecoin/pull/100</li>
<li>docs: finalize derived hd address functions by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/99</li>
<li>constants: add header with address definitions by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/101</li>
<li>doc: updated guidance on bip39 by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/102</li>
<li>build: add extra line to eof's by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/103</li>
<li>Add Moon Files by @qlpqlp in https://github.com/dogecoinfoundation/libdogecoin/pull/98</li>
<li>sign: add message signing and verification by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/104</li>
<li>Add key to signing-keys by @edtubbs in https://github.com/dogecoinfoundation/libdogecoin/pull/106</li>
<li>build: combine libunistring.a in gitian descriptors by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/107</li>
<li>docs: update changelog.md by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/108</li>
<li>fixate 0.1.2 as release by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/109</li>
</ul>
<h2 id="new-contributors-2"><a class="header" href="#new-contributors-2">New Contributors</a></h2>
<ul>
<li>@edtubbs made their first contribution in https://github.com/dogecoinfoundation/libdogecoin/pull/91</li>
<li>@qlpqlp made their first contribution in https://github.com/dogecoinfoundation/libdogecoin/pull/98</li>
</ul>
<p><strong>Full Changelog</strong>: https://github.com/dogecoinfoundation/libdogecoin/compare/v0.1.1...v0.1.2</p>
<h2 id="released-1"><a class="header" href="#released-1">[Released]</a></h2>
<h2 id="011---2022-10-03"><a class="header" href="#011---2022-10-03">[0.1.1] - 2022-10-03</a></h2>
<h2 id="whats-changed-2"><a class="header" href="#whats-changed-2">What's Changed</a></h2>
<ul>
<li>fixate 0.1.0 by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/59</li>
<li>open 0.1.1-dev for development by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/60</li>
<li>Fix all go get errors caused by rename by @quackduck in https://github.com/dogecoinfoundation/libdogecoin/pull/64</li>
<li>fix bad path for python wrapper in docs by @just-an-dev in https://github.com/dogecoinfoundation/libdogecoin/pull/68</li>
<li>Fix for dogecoin_script_copy_without_op_codeseperator todo by @nooperation in https://github.com/dogecoinfoundation/libdogecoin/pull/72</li>
<li>Remove VLAs (variable-length-arrays) from the code.  Fix some allocations. by @michilumin in https://github.com/dogecoinfoundation/libdogecoin/pull/75</li>
<li>Fixed memory cleanup issue in dogecoin_base58_encode_check and updated its declaration by @nooperation in https://github.com/dogecoinfoundation/libdogecoin/pull/76</li>
<li>address: fix memleaks caused from excessive key lengths by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/77</li>
<li>address: adds getDerivedHDAddress functions by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/78</li>
<li>Fixed command and ouputs for HD by @nformant1 in https://github.com/dogecoinfoundation/libdogecoin/pull/79</li>
<li>(API Change) Fixed the truncation of size_t's to int's in some places by @nooperation in https://github.com/dogecoinfoundation/libdogecoin/pull/80</li>
</ul>
<h2 id="new-contributors-3"><a class="header" href="#new-contributors-3">New Contributors</a></h2>
<ul>
<li>@quackduck made their first contribution in https://github.com/dogecoinfoundation/libdogecoin/pull/64</li>
<li>@just-an-dev made their first contribution in https://github.com/dogecoinfoundation/libdogecoin/pull/68</li>
<li>@nooperation made their first contribution in https://github.com/dogecoinfoundation/libdogecoin/pull/72</li>
<li>@nformant1 made their first contribution in https://github.com/dogecoinfoundation/libdogecoin/pull/79</li>
</ul>
<p><strong>Full Changelog</strong>: https://github.com/dogecoinfoundation/libdogecoin/compare/v0.1.0...v0.1.1</p>
<h2 id="released-2"><a class="header" href="#released-2">[Released]</a></h2>
<h2 id="010---2022-08-05"><a class="header" href="#010---2022-08-05">[0.1.0] - 2022-08-05</a></h2>
<h2 id="whats-changed-3"><a class="header" href="#whats-changed-3">What's Changed</a></h2>
<ul>
<li>docs: mv diagrams/ to doc/ and amend README.md by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/6</li>
<li>0.1-dev-autoreconf by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/8</li>
<li>qa: omit python from codeql by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/9</li>
<li>crypto: sha2, rmd160 by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/11</li>
<li>deps: bitcoin-core/secp256k1 subtree by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/12</li>
<li>feature: address by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/13</li>
<li>Example doc format by @tjstebbing in https://github.com/dogecoinfoundation/libdogecoin/pull/15</li>
<li>Creating first Python wrapper PR by @jaxlotl in https://github.com/dogecoinfoundation/libdogecoin/pull/14</li>
<li>qa: address_test by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/18</li>
<li>contrib: formatting by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/21</li>
<li>Verify address by @jaxlotl in https://github.com/dogecoinfoundation/libdogecoin/pull/22</li>
<li>mem: fix memleaks by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/24</li>
<li>Python module refactoring by @jaxlotl in https://github.com/dogecoinfoundation/libdogecoin/pull/25</li>
<li>Fixing compiler warnings - new_line by @DrinoSan in https://github.com/dogecoinfoundation/libdogecoin/pull/29</li>
<li>Documentation by @jaxlotl in https://github.com/dogecoinfoundation/libdogecoin/pull/27</li>
<li>Fixing unit_tests - Increase size of char array by @DrinoSan in https://github.com/dogecoinfoundation/libdogecoin/pull/32</li>
<li>C improved tests by @jaxlotl in https://github.com/dogecoinfoundation/libdogecoin/pull/31</li>
<li>Setting fixed size for priv and pubkeys in generatePrivPubKeypair and… by @DrinoSan in https://github.com/dogecoinfoundation/libdogecoin/pull/34</li>
<li>such: transaction by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/33</li>
<li>security: refactor koinu conversion functions by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/42</li>
<li>ci: fix apt-get update step for i686-w64-mingw32 by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/45</li>
<li>issue template updated to prevent spam in repository by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/44</li>
<li>transaction: remove all refs to segwit and bech32 by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/46</li>
<li>security: implement refactored conversion functions by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/43</li>
<li>trivial: fix up headers by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/47</li>
<li>include: delete valgrind/valgrind.h by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/48</li>
<li>cmake: add koinu to CMakeLists.txt by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/49</li>
<li>crypto: fix mismatched bound on sha256/512_finalize by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/51</li>
<li>tx: remove bloat from dogecoin_tx_sign_input by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/52</li>
<li>net: move broadcast_tx from tx to net by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/50</li>
<li>trivial: fix remaining GCC warnings/errors by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/53</li>
<li>contrib: update expired signing key for xanimo by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/55</li>
<li>build: backport autotools/gitian build system by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/54</li>
<li>doc: update changelog by @xanimo in https://github.com/dogecoinfoundation/libdogecoin/pull/58</li>
</ul>
<h2 id="contributors"><a class="header" href="#contributors">Contributors</a></h2>
<ul>
<li>@DrinoSan</li>
<li>@jaxlotl</li>
<li>@michilumin</li>
<li>@tjstebbing</li>
<li>@xanimo</li>
</ul>
<p><strong>Full Changelog</strong>: https://github.com/dogecoinfoundation/libdogecoin/commits/main</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
