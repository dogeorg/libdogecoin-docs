<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Transaction - Libdogecoin, a clean C library of Dogecoin building blocks</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Libdogecoin will be a complete implementation of the Dogecoin Protocols, as a C library (and series of bindings to popular languages) which will allow anyone to build a Dogecoin compliant product, without needing to worry about the deeper, complicated specifics of the crypto functions.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Libdogecoin, a clean C library of Dogecoin building blocks</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/dogecoinfoundation/libdogecoin/tree/main/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/dogeorg/libdogecoin-docs/edit/main/src/transaction.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="libdogecoin-transaction-api"><a class="header" href="#libdogecoin-transaction-api">Libdogecoin Transaction API</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#libdogecoin-transaction-api">Libdogecoin Transaction API</a>
<ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#working-transaction-api">Working Transaction API</a>
<ul>
<li><a href="#new_transaction"><strong>new_transaction</strong></a></li>
<li><a href="#add_transaction"><strong>add_transaction</strong></a></li>
<li><a href="#find_transaction"><strong>find_transaction</strong></a></li>
<li><a href="#remove_transaction"><strong>remove_transaction</strong></a></li>
</ul>
</li>
<li><a href="#essential-transaction-api">Essential Transaction API</a>
<ul>
<li><a href="#start_transaction"><strong>start_transaction</strong></a></li>
<li><a href="#add_utxo"><strong>add_utxo</strong></a></li>
<li><a href="#add_output"><strong>add_output</strong></a></li>
<li><a href="#finalize_transaction"><strong>finalize_transaction</strong></a></li>
<li><a href="#finalize_transaction_ex"><strong>finalize_transaction_ex</strong></a></li>
<li><a href="#get_raw_transaction"><strong>get_raw_transaction</strong></a></li>
<li><a href="#get_raw_transaction_ex"><strong>get_raw_transaction_ex</strong></a></li>
<li><a href="#clear_transaction"><strong>clear_transaction</strong></a></li>
<li><a href="#sign_raw_transaction"><strong>sign_raw_transaction</strong></a></li>
<li><a href="#sign_raw_transaction_ex"><strong>sign_raw_transaction_ex</strong></a></li>
<li><a href="#sign_transaction"><strong>sign_transaction</strong></a></li>
<li><a href="#store_raw_transaction"><strong>store_raw_transaction</strong></a></li>
<li><a href="#sign_indexed_raw_transaction_ex"><strong>sign_indexed_raw_transaction_ex</strong></a></li>
<li><a href="#sign_transaction_ex"><strong>sign_transaction_ex</strong></a></li>
<li><a href="#sign_transaction_w_privkey_ex"><strong>sign_transaction_w_privkey_ex</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>The high level 'essential' API provided by libdogecoin for working with simple transactions revolve around a structure defined as a <code>working_transaction</code> which is comprised of an index as an integer meant for retrieval, a dogecoin_tx 'transaction' structure as seen above, and finally a UT_hash_handle which stores our working_transaction struct in a hash table (using Troy D. Hanson's uthash library: see ./include/dogecoin/uthash.h and visit https://troydhanson.github.io/uthash/ for more information) which allow us to generate multiple transactions per "session". This <code>working_transaction</code> structure is defined as such:</p>
<pre><code class="language-C">typedef struct working_transaction {
    int index;
    dogecoin_tx* transaction;
    UT_hash_handle hh;
} working_transaction;
</code></pre>
<p>The functions that have been built around this <code>working_transaction</code> structure and flow of operation are comprised of 4 macros, which are explained further in the following section describing the <a href="#working-transaction-api">working transaction API</a>. used to interact with uthash. For more detailed technical information about the <code>dogecoin_tx</code> structure and Dogecoin transactions in general, please refer to the <a href="./transaction_extended.html">extended transaction documentation</a>.</p>
<p>The api itself is a higher level interface that contains all the necessary operations for building Dogecoin transactions from scratch. The generic process for building a transaction is as follows:</p>
<ul>
<li>Create an empty transaction.</li>
<li>Add inputs from your wallet's UTXOs.</li>
<li>Add outputs describing amount and recipient.</li>
<li>Return any leftover change back to your address.</li>
<li>Sign all inputs with your wallet's private key.</li>
</ul>
<p>All of these steps can be done purely with Libdogecoin API, by calling directly from C and including the "libdogecoin.h" header file. For details on the usage of this API, jump to the <a href="#essential-transaction-api">Essential API</a> section.</p>
<h2 id="working-transaction-api"><a class="header" href="#working-transaction-api">Working Transaction API</a></h2>
<p>These functions are designed to be "under the hood" and obfuscated from the end user as you will see in the Essential functions later on. They are to be used for manipulating the hash table which stores transactions in memory, and are already implemented within the Essential functions, so there is no need to call them again.</p>
<hr />
<h3 id="new_transaction"><a class="header" href="#new_transaction"><strong>new_transaction</strong></a></h3>
<p><code>working_transaction* new_transaction()</code></p>
<p>This function instantiates a new working_transaction structure for use. It allocates memory using <code>dogecoin_calloc()</code>, auto increments the index, instantiates a new dogecoin_tx structure, adds the working_transaction to the hash table and finally returns a pointer to the newly created working_transaction.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">working_transaction* transaction = new_transaction();
</code></pre>
<hr />
<h3 id="add_transaction"><a class="header" href="#add_transaction"><strong>add_transaction</strong></a></h3>
<p><code>void add_transaction(working_transaction *working_tx)</code></p>
<p>This function takes a working_transaction generated from <code>new_transaction()</code> and adds it to the hash table.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">working_transaction* working_tx = new_transaction();
add_transaction(working_tx);
</code></pre>
<hr />
<h3 id="find_transaction"><a class="header" href="#find_transaction"><strong>find_transaction</strong></a></h3>
<p><code>working_transaction* find_transaction(int idx)</code></p>
<p>This function returns a pointer to the working transaction at the specified index. If no transaction exists at that index, the function will return a NULL pointer.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">working_transaction* working_tx = find_transaction(1);
</code></pre>
<hr />
<h3 id="remove_transaction"><a class="header" href="#remove_transaction"><strong>remove_transaction</strong></a></h3>
<p><code>void remove_transaction(working_transaction *working_tx)</code></p>
<p>This function removes a working_transaction from the hash table and deallocates all memory dedicated to the working_transaction and the objects it contains using <code>dogecoin_free()</code>.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">working_transaction* working_tx = find_transaction(1);
remove_transaction(working_tx);
</code></pre>
<h2 id="essential-transaction-api"><a class="header" href="#essential-transaction-api">Essential Transaction API</a></h2>
<p>These functions implement the core functionality of Libdogecoin for building transactions, and are described in depth below. You can access them through a C program, by including the <code>libdogecoin.h</code> header in the source code and including the <code>libdogecoin.a</code> library at compile time.</p>
<hr />
<h3 id="start_transaction"><a class="header" href="#start_transaction"><strong>start_transaction</strong></a></h3>
<p><code>int start_transaction()</code></p>
<p>This function instantiates a new working_transaction structure and returns its index for future retrieval as an integer. This new working_transaction will contain an empty hex, which is "01000000000000000000". Note that anytime a new working transaction is created, it must also be removed at the end of the session by calling either <code>clear_transaction()</code>, otherwise a memory leak may occur.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"

int main() {
    int index = start_transaction();
    // build onto the working transaction here
    clear_transaction(index);
}
</code></pre>
<hr />
<h3 id="add_utxo"><a class="header" href="#add_utxo"><strong>add_utxo</strong></a></h3>
<p><code>int add_utxo(int txindex, char* hex_utxo_txid, int vout)</code></p>
<p>An unspent transaction output (utxo) is an output of a previous transaction in which funds were sent to the user's address. These can be spent by including them as inputs in a new transaction. This function takes in a working_transaction's index as an integer (txindex), a raw hexadecimal string id of the transaction containing the utxo to spend (hex_utxo_txid), and index of the desired utxo within the previous transaction's list of outputs (vout). The utxo is then added to the working_transaction-&gt;transaction-&gt;vin field, returning either 1 for success or 0 for failure.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"

int main() {
    char* prev_output_txid = "b4455e7b7b7acb51fb6feba7a2702c42a5100f61f61abafa31851ed6ae076074"; // worth 2 dogecoin
    int prev_output_n = 1;

    int index = start_transaction();
    if (!add_utxo(index, prev_output_txid, prev_output_n)) {
        // handle failure, return false; or printf("failure\n"); etc...
    }
    clear_transaction(index);
}
</code></pre>
<hr />
<h3 id="add_output"><a class="header" href="#add_output"><strong>add_output</strong></a></h3>
<p><code>int add_output(int txindex, char* destinationaddress, char* amount)</code></p>
<p>In order to actually spend utxos, the user must specify the new recipient address and how much of the total input amount will be sent to this address. This function takes in a working_transaction's index as an integer (txindex), the string p2pkh address of the new recipient (destinationaddress), and the amount in Dogecoin (amount) to send. This new output will be added to the working_transaction-&gt;transaction-&gt;vout field, returning either 1 for success or 0 for failure.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"

int main() {
    char* prev_output_txid = "42113bdc65fc2943cf0359ea1a24ced0b6b0b5290db4c63a3329c6601c4616e2"; // worth 10 dogecoin
    int prev_output_n = 1;
    char* external_address = "nbGfXLskPh7eM1iG5zz5EfDkkNTo9TRmde";

    int index = start_transaction();
    add_utxo(index, prev_output_txid, prev_output_n);
    if (!add_output(index, external_address, "5.0")) { // 5 dogecoin to be sent
        // error handling here
    }
    clear_transaction(index);
}
</code></pre>
<hr />
<h3 id="finalize_transaction"><a class="header" href="#finalize_transaction"><strong>finalize_transaction</strong></a></h3>
<p><code>char* finalize_transaction(int txindex, char* destinationaddress, char* subtractedfee, char* out_dogeamount_for_verification, char* changeaddress)</code></p>
<p>Because Dogecoin protocol requires that utxos must be spent in full, an additional output is usually included in a transaction to return all the leftover funds to the sender. This function automatically handles both creating this extra output and reserving some funds for the network fee. It takes in a working_transaction's index as an integer (txindex), the external destination address we are sending to (destinationaddress), the desired fee to be subtracted (subtractedfee), the total amount of all inputs included through <code>add_utxo()</code> (out_dogeamount_for_verification), and the public key of the sender (public_key). In addition to making change and deducting the fee, it checks that all of the recipients included in the transaction outputs are valid by converting their script hashes to p2pkh, and returns false if any are not found. Otherwise, the hex of the finalized transaction is returned as a string.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
    char* prev_output_txid_2 = "b4455e7b7b7acb51fb6feba7a2702c42a5100f61f61abafa31851ed6ae076074"; // worth 2 dogecoin
    char* prev_output_txid_10 = "42113bdc65fc2943cf0359ea1a24ced0b6b0b5290db4c63a3329c6601c4616e2"; // worth 10 dogecoin
    int prev_output_n_2 = 1;
    int prev_output_n_10 = 1;
    char* external_address = "nbGfXLskPh7eM1iG5zz5EfDkkNTo9TRmde";
    char* my_address = "noxKJyGPugPRN4wqvrwsrtYXuQCk7yQEsy";

    int index = start_transaction();
    add_utxo(index, prev_output_txid_2, prev_output_n_2);
    add_utxo(index, prev_output_txid_10, prev_output_n_10);
    add_output(index, external_address, "5.0");

    // finalize transaction with min fee of 0.00226 doge on the input total of 12 dogecoin
    char* rawhex = finalize_transaction(index, external_address, "0.00226", "12.0", my_address);
    printf("Finalized transaction hex is %s.", rawhex);
    clear_transaction(index);
}
</code></pre>
<hr />
<h3 id="finalize_transaction_ex"><a class="header" href="#finalize_transaction_ex"><strong>finalize_transaction_ex</strong></a></h3>
<pre><code class="language-c">int finalize_transaction_ex(int txindex, const char* destinationaddress, const char* subtractedfee, const char* total_in_doge, const char* changeaddress, char* out_hex, size_t out_cap);
</code></pre>
<p><code>finalize_transaction_ex</code> one-shots the <em>“close &amp; return change”</em> step while <strong>avoiding a heap allocation</strong>: it finalizes the working transaction at <code>txindex</code>, figures out fees / change exactly as <code>finalize_transaction()</code> does, hex-serialises the result straight into the caller-supplied buffer <code>out_hex</code> (whose capacity in bytes is <code>out_cap</code>), then returns the number of characters written (not counting the terminating <code>'\0'</code>).
If any argument is invalid or the buffer is too small the function returns 0.</p>
<p><em>C usage:</em></p>
<pre><code class="language-c">// build the TX (add_utxo / add_output)

char txhex[TXHEXMAXLEN + 1];          // +1 for the NUL
int n = finalize_transaction_ex(idx,
                                "nbGfXLskPh7eM1iG5zz5EfDkkNTo9TRmde", // destination
                                "0.00226",                            // fee
                                "12.0",                               // total inputs
                                "noxKJyGPugPRN4wqvrwsrtYXuQCk7yQEsy", // change back here
                                txhex,
                                sizeof(txhex));

if (n == 0) {
    // handle error
} else {
    printf("Finalised TX (%d chars):\n%s\n", n, txhex);
}
</code></pre>
<hr />
<h3 id="get_raw_transaction"><a class="header" href="#get_raw_transaction"><strong>get_raw_transaction</strong></a></h3>
<p><code>char* get_raw_transaction(int txindex)</code></p>
<p>This function takes in a working_transaction's index as an integer (txindex) and returns the current working_transaction in raw hexadecimal format.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
    int index = start_transaction();
    char* rawhex = get_raw_transaction(index);
    printf("The transaction hex at index %d is %s.\n", index, rawhex);
    clear_transaction(index);
}
</code></pre>
<hr />
<h3 id="get_raw_transaction_ex"><a class="header" href="#get_raw_transaction_ex"><strong>get_raw_transaction_ex</strong></a></h3>
<pre><code class="language-c">int get_raw_transaction_ex(int   txindex,
                           char* buf,
                           size_t buf_cap);
</code></pre>
<p>The <code>get_raw_transaction_ex</code> function writes the raw hexadecimal representation of the working transaction at index <code>txindex</code> into the caller-supplied buffer <code>buf</code> (of total size <code>buf_cap</code>). On success it returns the number of characters written (not counting the terminating <code>'\0'</code>); if the index is invalid, a pointer is NULL, or the buffer is too small, it returns 0. Unlike <code>get_raw_transaction()</code>, this version avoids allocating a new string on the heap, making it ideal when you already manage your own buffer.</p>
<p><em>C usage:</em></p>
<pre><code class="language-c">char buf[TXHEXMAXLEN + 1];
int len = get_raw_transaction_ex(index, buf, sizeof(buf));
if (len == 0) {
    // handle error
} else {
    printf("Transaction hex: %s\n", buf);
}
</code></pre>
<hr />
<h3 id="clear_transaction"><a class="header" href="#clear_transaction"><strong>clear_transaction</strong></a></h3>
<p><code>void clear_transaction(int txindex)</code></p>
<p>This function takes in a working_transaction's index as an integer (txindex), and removes the transaction at that index from the hash table. All memory dedicated to transaction objects, such as dogecoin_tx_in and dogecoin_tx_out, is freed from within this function.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
    int index = start_transaction();
    clear_transaction(index);
    printf("The transaction hex at index %d is %s.\n", index, get_raw_transaction(index)); // should return (null)
}
</code></pre>
<hr />
<h3 id="sign_raw_transaction"><a class="header" href="#sign_raw_transaction"><strong>sign_raw_transaction</strong></a></h3>
<p><code>int sign_raw_transaction(int inputindex, char* incomingrawtx, char* scripthex, int sighashtype, char* privkey)</code></p>
<p>This function takes in an index denoting which of the current transaction's inputs to sign (inputindex), the raw hexadecimal representation of the transaction to sign (incomingrawtx), the pubkey script in hexadecimal format (scripthex), the signature hash type (sighashtype) and the WIF-encoded private key used to sign the input (privkey). Signature hash type in normal use cases is set to 1 to denote that anyone can pay. In C, the function returns a boolean denoting success, but the actual signed transaction hex is passed back through incomingrawtx. <strong>Important:</strong> <code>sign_raw_transaction</code> must be run within a secp256k1 context, which can be created by calling <code>dogecoin_ecc_start()</code> and <code>dogecoin_ecc_stop()</code> as shown below.</p>
<p><strong>Note:</strong> The <code>incomingrawtx</code> buffer <strong>must</strong> be the buffer returned by <code>get_raw_transaction()</code>, otherwise the signed hex may overflow.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
    char* prev_output_txid_2 = "b4455e7b7b7acb51fb6feba7a2702c42a5100f61f61abafa31851ed6ae076074"; // worth 2 dogecoin
    char* prev_output_txid_10 = "42113bdc65fc2943cf0359ea1a24ced0b6b0b5290db4c63a3329c6601c4616e2"; // worth 10 dogecoin
    int prev_output_n_2 = 1;
    int prev_output_n_10 = 1;
    char* external_address = "nbGfXLskPh7eM1iG5zz5EfDkkNTo9TRmde";
    char* my_address = "noxKJyGPugPRN4wqvrwsrtYXuQCk7yQEsy";
    char* my_script_pubkey = "76a914d8c43e6f68ca4ea1e9b93da2d1e3a95118fa4a7c88ac";
    char* my_privkey = "ci5prbqz7jXyFPVWKkHhPq4a9N8Dag3TpeRfuqqC2Nfr7gSqx1fy";

    int index = start_transaction();
    add_utxo(index, prev_output_txid_2, prev_output_n_2);
    add_utxo(index, prev_output_txid_10, prev_output_n_10);
    add_output(index, external_address, "5.0");
    finalize_transaction(index, external_address, "0.00226", "12.0", my_address);

    //sign both inputs of the current finalized transaction
    dogecoin_ecc_start();
    char* rawhex = get_raw_transaction(index);
    sign_raw_transaction(0, rawhex, my_script_pubkey, 1, my_privkey);
    sign_raw_transaction(1, rawhex, my_script_pubkey, 1, my_privkey);
    dogecoin_ecc_stop();
    printf("The final signed transaction hex is: %s\n", rawhex);
    clear_transaction(index);
}
</code></pre>
<hr />
<h3 id="sign_raw_transaction_ex"><a class="header" href="#sign_raw_transaction_ex"><strong>sign_raw_transaction_ex</strong></a></h3>
<pre><code class="language-c">int sign_raw_transaction_ex(int           inputindex,
                            const char*   incomingrawtx,
                            char*         signedrawtx,
                            size_t*       signed_size,
                            const char*   scripthex,
                            int           sighashtype,
                            const char*   privkey);
</code></pre>
<p>The <code>sign_raw_transaction_ex</code> function offers a two-step interface for signing a single input of a raw transaction. In <strong>query mode</strong>, you pass <code>signedrawtx == NULL</code>; the function writes the required buffer size (including the null terminator) into <code>*signed_size</code> and returns 1. In <strong>write mode</strong>, you allocate at least that many bytes, pass the buffer in <code>signedrawtx</code> (with <code>*signed_size</code> set to its capacity), and call it again. On success it writes the signed transaction hex (plus <code>'\0'</code>) into your buffer and returns 1; on failure it returns 0. This pattern avoids extra heap allocations when you want to supply your own output buffer.</p>
<p><em>C usage:</em></p>
<pre><code class="language-c">// Stage 1: query required size
size_t need = 0;
if (!sign_raw_transaction_ex(0, rawhex, NULL, &amp;need, scripthex, 1, wif)) {
    // error
}

// Stage 2: allocate and sign
char *out = malloc(need);
if (!out) { /* OOM */ }
if (!sign_raw_transaction_ex(0, rawhex, out, &amp;need, scripthex, 1, wif)) {
    // error
}
printf("Signed transaction: %s\n", out);
free(out);
</code></pre>
<hr />
<h3 id="sign_transaction"><a class="header" href="#sign_transaction"><strong>sign_transaction</strong></a></h3>
<p><code>int sign_transaction(int txindex, char* script_pubkey, char* privkey)</code></p>
<p>This function takes in a working transaction structure's index as an integer (txindex), the pubkey in script hex form (script_pubkey) and the WIF-encoded private key (privkey). Each input is then signed using the specified private key, and the final signed transaction is saved to the hash table, which can be retrieved using <code>get_raw_transaction()</code>. The return value of <code>sign_transaction()</code> is a boolean denoting whether the signing was successful, but the output from <code>get_raw_transaction()</code> is a fully signed transaction that--if all information is valid--can be broadcast to miners and incorporated into the blockchain. <strong>Important:</strong> <code>sign_transaction</code> must also be run within a secp256k1 context, which can be created by calling <code>dogecoin_ecc_start()</code> and <code>dogecoin_ecc_stop()</code> as shown below.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
    char* prev_output_txid_2 = "b4455e7b7b7acb51fb6feba7a2702c42a5100f61f61abafa31851ed6ae076074"; // worth 2 dogecoin
    char* prev_output_txid_10 = "42113bdc65fc2943cf0359ea1a24ced0b6b0b5290db4c63a3329c6601c4616e2"; // worth 10 dogecoin
    int prev_output_n_2 = 1;
    int prev_output_n_10 = 1;
    char* external_address = "nbGfXLskPh7eM1iG5zz5EfDkkNTo9TRmde";
    char* my_address = "noxKJyGPugPRN4wqvrwsrtYXuQCk7yQEsy";
    char* my_script_pubkey = "76a914d8c43e6f68ca4ea1e9b93da2d1e3a95118fa4a7c88ac";
    char* my_privkey = "ci5prbqz7jXyFPVWKkHhPq4a9N8Dag3TpeRfuqqC2Nfr7gSqx1fy";

    int index = start_transaction();
    add_utxo(index, prev_output_txid_2, prev_output_n_2);
    add_utxo(index, prev_output_txid_10, prev_output_n_10);
    add_output(index, external_address, "5.0");
    finalize_transaction(index, external_address, "0.00226", "12.0", my_address);

    //sign both inputs of the current finalized transaction
    dogecoin_ecc_start();
    if (!sign_transaction(index, my_script_pubkey, my_privkey)) {
        // error handling here
    }
    dogecoin_ecc_stop();
    printf("The final signed transaction hex is: %s\n", get_raw_transaction(index));
    clear_transaction(index);
}
</code></pre>
<hr />
<h3 id="store_raw_transaction"><a class="header" href="#store_raw_transaction"><strong>store_raw_transaction</strong></a></h3>
<p><code>int store_raw_transaction(char* incomingrawtx)</code></p>
<p>This function is equivalent to <code>save_raw_transaction</code> but takes the next available index in the hash table to save the provided transaction hex (incomingrawtx), rather than allowing the user to specify which index. It then returns this automatically chosen index as an integer.</p>
<p><em>C usage:</em></p>
<pre><code class="language-C">#include "libdogecoin.h"
#include &lt;stdio.h&gt;

int main() {
    char* hex_to_store = "0100000001746007aed61e8531faba1af6610f10a5422c70a2a7eb6ffb51cb7a7b7b5e45b40100000000ffffffff0000000000";
    int index = store_raw_transaction(hex_to_store);
    printf("The transaction hex at index %d is %s.\n", index, get_raw_transaction(index));
    clear_transaction(index);
}
</code></pre>
<hr />
<h3 id="sign_indexed_raw_transaction_ex"><a class="header" href="#sign_indexed_raw_transaction_ex"><strong>sign_indexed_raw_transaction_ex</strong></a></h3>
<pre><code class="language-c">int sign_indexed_raw_transaction_ex(int txindex,
                                    int inputindex,
                                    const char* scripthex,
                                    int sighashtype,
                                    const char* privkey,
                                    char* buf,
                                    size_t buf_cap);
</code></pre>
<p>Signs <strong>one</strong> specific input (<code>inputindex</code>) of the working transaction stored at <code>txindex</code>, writes the fully-updated raw-hex straight into the caller-supplied buffer <code>buf</code> (capacity <code>buf_cap</code>) and returns the number of hex characters written (not counting the terminating <code>'\0'</code>).
If the buffer is too small or any argument is invalid the function returns 0.</p>
<pre><code class="language-c">char signedhex[TXHEXMAXLEN + 1];
int n = sign_indexed_raw_transaction_ex(idx,        /* tx we're editing   */
                                        0,          /* which vin to sign  */
                                        scripthex,  /* utxo's scriptPubKey*/
                                        1,          /* SIGHASH_ALL        */
                                        wif,        /* signing key        */
                                        signedhex,
                                        sizeof signedhex);
if (n == 0) { /* error */ }
</code></pre>
<h3 id="sign_transaction_ex"><a class="header" href="#sign_transaction_ex"><strong>sign_transaction_ex</strong></a></h3>
<pre><code class="language-c">int sign_transaction_ex(int txindex,
                         const char* script_pubkey,
                         const char* privkey,
                         char* buf,
                         size_t buf_cap);
</code></pre>
<p>High-level helper that iterates over <strong>all</strong> inputs of the working transaction at <code>txindex</code>, signing each one with the same <code>script_pubkey</code> / <code>privkey</code> pair, then emits the completely-signed transaction hex into <code>buf</code>.
Return-value semantics are identical to the previous function.</p>
<pre><code class="language-c">char finalhex[TXHEXMAXLEN + 1];
if (!sign_transaction_ex(idx, scripthex, wif, finalhex, sizeof finalhex)) {
    /* signing failed */
}
printf("fully-signed tx:\n%s\n", finalhex);
</code></pre>
<h3 id="sign_transaction_w_privkey_ex"><a class="header" href="#sign_transaction_w_privkey_ex"><strong>sign_transaction_w_privkey_ex</strong></a></h3>
<pre><code class="language-c">int sign_transaction_w_privkey_ex(int txindex,
                                  const char* privkey,
                                  char* buf,
                                  size_t buf_cap);
</code></pre>
<p>Single-key convenience wrapper: derives the P2PKH <code>scriptPubKey</code> from <code>privkey</code>, signs <strong>every</strong> input of the transaction at <code>txindex</code>, and streams the result into <code>buf</code>.
Ideal for the common <em>all inputs belong to the same wallet</em> scenario.</p>
<pre><code class="language-c">char txhex[TXHEXMAXLEN + 1];
if (!sign_transaction_w_privkey_ex(idx, wif, txhex, sizeof txhex)) {
    /* error */
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="tools.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="transaction_extended.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="tools.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="transaction_extended.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
